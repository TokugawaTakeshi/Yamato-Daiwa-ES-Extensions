extends ../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../SharedAssets/Markup/SharedAssets.russian.pug
  include ../../../SharedComponents/SharedComponents.russian.pug


block append Metadata

  -

    HTML_PAGE_LANGUAGE = "ru";
    HTML_PAGE_TITLE = buildHTML_PageTitle("ObjectDataFilesProcessor");
    HTML_PageMetaData = {
      description: MetaDescriptionTemplates.class({
        className: "getLastElementOfArray",
        whatIsClassFor:
            "предназначен для парсинга файлов с данными форматов «YAML», «JSON5» или «DotEnv», валидации этих данных" +
              "и приведения их к конкретному TypeScript-типу."
      }),
      author: HTML_PAGE_AUTHOR
    };

    FAVICON_URI = "@MustBeInPublicRoot/favicon";

    styleSheetsURIs = [ "@Shared/CommonStyles", "@Layouts/TwoColumns/TwoColumnsLayout", "@Shared/ExternalComponents" ];
    scriptsURIs.endOfBody = [ "$CommonLogic" ];

    RoutingEmulator.setCurrentRoute("nodeJS.utils.ObjectDataFilesProcessor");

    LanguageDropDownList__YDF_DK.setLinks({
      english: "./ObjectDataFilesProcessor.english.html",
      japanese: "./ObjectDataFilesProcessor.japanese.html"
    });


block append HeadScriptsLinks

  if __IS_PRODUCTION_BUILDING_MODE__

    +GoogleAnalyticsScript


block append SpecificContent

  article

    h1.Article-Heading1 Класс #[code «ObjectDataFilesProcessor»]

    p.Article-Paragraph
      | #[+Term--YDID Класс] для чтения файлов, содержащих #[+Term--YDID объектные данные] в одном из указанных ниже
      |   форматов и валидации этих данных с приведением к конкретному #[+Term--YDID TypeScript-типу], удовлетворяющего
      |   #[+Term--YDID ограничению дженерика]
      |
      +Link--YDF({
        internalURI: localizedRouting.coreLibrary.$children.
            functionality.$children.
            types.$children.
            ParsedJSON_AndRelated.$URI,
      }).Article-Link ParsedJSON
      |  .

    ul.Article-UnorderedList
      li YAML
      li DotEnv
      li JSON5


    h2.Article-Heading2 Проблематика

    p.Article-Paragraph.
      Изначально, #[+ImportantEntity--YDID Node.js] #[+Keyword--YDID не]&nbsp;поддерживает разбор файлов упомянутых выше
        форматов — эти файлы можно лишь прочитать с результатом в виде строки, однако функциональности для преобразования
        строки в #[+Term--YDID объект] у #[+ImportantEntity--YDID Node.js] #[+Keyword--YDID нет].
      Разумеется, ввиду популярности этих форматов данных для их разбора существуют сторонние
        библиотеки, однако многие из них перед преобразованием в объект #[+Term--YDID лишь] проверяют их
        на соответствие целевому формату и возвращают объект типа #[+ImportantEntity__Code--YDID any].
      Вот, например, определения #[+Term--YDID TypeScript-типов] для библиотеки #[+ImportantEntity--YDID yaml.js] версии
        #[+ImportantEntity--YDID 0.2.31]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }).
        declare namespace YAML {

          function load(path: string): any;

          function load(path: string, callback: (res: any) => void): void

          function stringify(nativeObject: any, inline?: number, spaces?: number): string;

          function parse(yamlString: string): any;

        }
    //- TODO 日本語 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    p.Article-Paragraph.
      Конечно, мы можем возвращаемому значению #[+ImportantEntity__Code--YDID any] назначить определённый тип через
        ключевое слово #[+ImportantEntity__Code--YDID as] (собственно, другого выхода и&nbsp;#[+Keyword--YDID нет],
        потому что #[+Term--YDID интерфейсы] и #[+Term--YDID псевдонимы типов] #[+Keyword--YDID прекращают] своё
        существование при #[+Term--YDID транспайлинге] в #[+ImportantEntity--YDID JavaScript],
        #[+Keyword--YDID не]&nbsp;оставляя никаких данных, на которые можно сослаться уже во время выполнения
        #[+ImportantEntity--YDID JavaScript]), однако использование #[+Term--YDID ключевого слова]
        #[+ImportantEntity__Code--YDID as] должно быть чем-то подкреплено, и в данном случае это должна быть
        валидация уже преобразованных в объект данных на соответствие требуемым ограничениям.
      Даже если Вы разрабатываете утилиту для личного пользования, допускание ошибок в файле с данными
        вполне вероятно, а потому валидация требуется и в таких случаях.
    //- TODO English ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    h3.Article-Heading3 Концептуальное решение

    p.Article-Paragraph.
      Для того, чтобы минимизировать вероятность возникновения ошибок при работе с файлами данных, необходимо:

    ol.Article-OrderedList
      li Прочитать этот файл и преобразовать его содержимое в #[+Term--YDID объект].
      li.
        Валидировать этот #[+Term--YDID объект], и если есть какие-либо несоответствия, то логировать
          #[+Keyphrase--YDID все, а не&nbsp;только первое из них].
      li.
        Если же #[+Term--YDID объект] прошёл валидацию, то только тогда уже использовать #[+Term--YDID приведение типов]
          (например, с помощью ключевого слова #[+ImportantEntity__Code--YDID as]).

    p.Article-Paragraph.
      Хотя гарантировать соответствие заданных правил валидации указанному #[+Term--YDID TypeScript-типу], к которому
        будет выполнено приведение #[+Term--YDID объекта] и #[+Keyword--YDID невозможно],
        #[+Keyphrase--YDID наличие валидации всё равно крайне важно], потому что как показывает практика,
        даже в условиях технических ограничений #[+ImportantEntity--YDID TypeScript], наличие валидации
        позволяет обнаружить несоответствия на ранней стадии и тем самым упростить отладку.

    h3.Article-Heading3 Решение #[code ObjectDataFilesProcessor]

    p.Article-Paragraph.
      В #[+Term--YDID классе] #[+ImportantEntity--YDID ObjectDataFilesProcessor] реализован приведённый выше алгоритм
        для нескольких форматов данных.

    ul.Article-UnorderedList

      li
        | Правила валидации описываются в формате
        |
        +Link--YDF({
          internalURI: localizedRouting.coreLibrary.$children.
              functionality.$children.
              RawObjectDataProcessor.
              $sectioning.API.$URI,
        }).Article-Link RawObjectDataProcessor

      li
        | #[+Term--YDID TypeScript-тип], к которому будет осуществляются приведение, должен быть расширением
        |
        +Link--YDF({
          internalURI: localizedRouting.coreLibrary.$children.
              functionality.$children.
              types.$children.
              ParsedJSON_AndRelated.$URI,
        }).Article-Link ParsedJSON
        |   .
      li Присутствует как синхронная реализация, так и асинхронная в возвращением результата в виде #[+Term--YDID промиса].

    p.Article-Paragraph.
      При необходимости можно с использованием #[+Term--YDID API] #[+Term--YDID класса]
        #[+ImportantEntity--YDID RawObjectDataProcessor] организовать подстановку значений по умолчанию или другие
        манипуляции с данными (постобработка).

    //- TODO Ограничения RawObjectDataProcessor
        1 Только те данные, что указаны
        2 Не поддерживаются кортежи

    h2.Article-Heading2 Программный интерфейс (API)

    p.Article-Paragraph.
      Будучи узкоспециализированным, #[+Term--YDID класс] #[+ImportantEntity--YDID ObjectDataFilesProcessor] является
        #[+Term--YDID абстрактным] и имеет только #[+Keyword--YDID один] #[+Term--YDID статический метод] и
        #[+Keyword--YDID одно] #[+Term--YDID статическое поле].


    h3.Article-Heading3 Статический метод #[code processFile] и его перегрузки

    p.Article-Paragraph.
      Считывает файл #[+Keyword--YDID поддерживаемого] типа данных, преобразует данные в
        #[+Term--YDID JavaScript-объект] и, если указаны правила валидации, то приводит этот
        #[+Term--YDID объект] к #[+Term__Contrast--YDID TypeScript-типу].

    ul.Article-UnorderedList

      li.
        Возможна как синхронная обработка, так и асинхронная — в последнем случае результат будет обёрнут в
          #[+Term--YDID промис].
      li.
        Если файл #[+Keyword--YDID не]&nbsp;имеет расширения, указывающего на тип поддерживаемый тип данных, то этот
          тип нужно указать явно с помощью #[+Term--YDID перечисления]
          #[+ImportantEntity--YDID ObjectDataFilesProcessor.SupportedSchemas].
      li.
        Если правила валидации&nbsp;#[+Keyword--YDID не]&nbsp;указаны, то будут возвращены данные типа
          #[+ImportantEntity__Code--YDID unknown].
        Однако, наличие валидации является основной причиной для использования
          #[+ImportantEntity--YDID ObjectDataFilesProcessor].


    h4.Article-Heading4 Асинхронная обработка с валидацией

    +CallableExpressionScheme--YDF_DK({
      technicalName: "processFile",
      genericParameters: [ { name: "ValidData", extends: "ParsedJSON" } ],
      parametersSpecification: [
        {
          genericTechnicalName: "compoundParameter",
          localizedName: "Составной параметр",
          type: "CompoundParameter",
          required: true
        }
      ],
      returnedValue: "Promise&lt;ValidData&gt;"
    })
      +ObjectTypeAbstract--YDF_DK({
        typeName: "CompoundParameter",
        localizedName: "Составной параметр",
        propertiesSpecification: {
          filePath: {
            localizedName: "Путь к файлу",
            type: "string",
            required: true
          },
          validDataSpecification: {
            localizedName: "Спецификация валидных данных",
            type: "RawObjectDataProcessor.ObjectDataSpecification",
            required: true
          },
          schema: {
            localizedName: "Формат",
            type: "ObjectDataFilesProcessor.SupportedSchemas",
            required: false
          },
          synchronously: {
            localizedInterpretation: "Синхронно",
            type: "boolean (только false)",
            required: true
          }
        }
      })

    p.Article-Paragraph.
      Указывая значение #[+ImportantEntity__Code--YDID false] #[+Term--YDID свойству]
        #[+ImportantEntity__Code--YDID synchronously], мы сообщаем о своём намерении получать результат в виде
        #[+Term--YDID промиса].

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }).
        import Path from "path;
        import { ObjectDataFilesProcessor, FileReadingFailedError } from "@yamato-daiwa/es-extensions-nodejs"

        type Sample = {
          foo: string;
          bar: number;
        };

        const filePath: string = Path.join(__dirname, "sample.yaml");
        const sample: Sample;

        try {

          sample = await ObjectDataFilesProcessor.processFile({ filePath, synchronously: false });

        } catch (error: unknown) {

          Logger.throwErrorAndLog({
            errorInstance: new FileReadingFailedError({ filePath }),
            title: FileReadingFailedError.localization.defaultTitle,
            occurrenceLocation: "markupProcessingRawSettingsNormalizer.normalizeImportsFromStaticDataFiles()",
            wrappableError: error
          });

        }

    h4.Article-Heading4 Асинхронная обработка с валидацией и постобработкой

    +CallableExpressionScheme--YDF_DK({
      technicalName: "processFile",
      genericParameters: [ {
        name: "ValidData",
        extends: "ParsedJSON"
      } ],
      parametersSpecification: [
        {
          genericTechnicalName: "compoundParameter",
          localizedName: "Составной параметр",
          type: "CompoundParameter",
          required: true
        }
      ],
      returnedValue: "ValidData"
    })
      +ObjectTypeAbstract--YDF_DK({
        typeName: "CompoundParameter",
        localizedName: "Составной параметр",
        propertiesSpecification: {
          filePath: {
            localizedName: "Путь к файлу",
            type: "string",
            required: true
          },
          validDataSpecification: {
            localizedName: "Спецификация валидных данных",
            type: "RawObjectDataProcessor.ObjectDataSpecification",
            required: true
          },
          schema: {
            localizedName: "Формат",
            type: "ObjectDataFilesProcessor.SupportedSchemas",
            required: false
          },
          synchronously: {
            localizedInterpretation: "Синхронно",
            type: "boolean (только false)",
            required: true
          }
        }
      })

    p.Article-Paragraph.
      Если требования к производительности Вашего программного продукта допускают использование тяжёлых (относительно)
        синхронных обработок, то можно указать опции #[+ImportantEntity__Code--YDID synchronously] значение
        #[+ImportantEntity__Code--YDID true].
      В этом случае при отсутствии ошибок метод #[+ImportantEntity__Code--YDID processFile] вернёт данные.

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }).
        import Path from "path;
        import { ObjectDataFilesProcessor, FileReadingFailedError } from "@yamato-daiwa/es-extensions-nodejs"

        type Sample = {
          foo: string;
          bar: number;
        };

        const filePath: string = Path.join(__dirname, "sample.yaml");
        const sample: Sample;

        try {

          sample = ObjectDataFilesProcessor.processFile({ filePath, synchronously: false });

        } catch (error: unknown) {

          Logger.throwErrorAndLog({
            errorInstance: new FileReadingFailedError({ filePath }),
            title: FileReadingFailedError.localization.defaultTitle,
            occurrenceLocation: "markupProcessingRawSettingsNormalizer.normalizeImportsFromStaticDataFiles()",
            wrappableError: error
          });

        }

    h4.Article-Heading4 Извлечение данных без валидации

    p.Article-Paragraph.
      Если Вы по какой-либо причине хотите использовать #[+ImportantEntity--YDID ObjectDataFilesProcessor], но
        не&nbsp;хотите использовать функциональность валидации, то будут возвращены считанные данные типа
        #[+ImportantEntity__Code--YDID unknown] (в асинхронном варианте эти данные будут обёрнуты в
        #[+Term--YDID промис]).


    h3.Article-Heading3 Локализация

    p.Article-Paragraph.
      Для того, чтобы переключить язык сообщений об ошибке, необходимо присвоить #[+Term--YDID статическому полю]
        #[+ImportantEntity__Code--YDID localization] #[+Term--YDID объект] типа
        #[+ImportantEntity__Code--YDID ObjectDataFilesProcessor.Localization].
      Русская локализация имеется (ссылка).

    //- TODO Добавить ссылку
    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }).
        ObjectDataFilesProcessor.localization = objectDataFilesProcessorLocalization__russian;

    p.Article-Paragraph.
      Если же Вам нужна другая локализация, по при этом она недоступна на #[+ImportantEntity__Code--YDID npm] то можете
        определить объект #[+ImportantEntity__Code--YDID ObjectDataFilesProcessor.Localization] самостоятельно.
      Ниже представлено определение этого #[+Term--YDID объекта].

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        export type Localization = Readonly<{

          generateUnableToDecideDataParsingAlgorithmErrorMessage: (
            templateVariables: Localization.UnableToDecideDataParsingAlgorithmErrorMessage.TemplateVariables
          ) => string;

          generateUnsupportedFileNameExtensionErrorMessage: (
            templateVariables: Localization.UnsupportedFileNameExtensionErrorMessage.TemplateVariables
          ) => string;

        }>;

        export namespace Localization {

          export namespace UnableToDecideDataParsingAlgorithmErrorMessage {
            export type TemplateVariables = Readonly<{
              filePath: string;
            }>;
          }

          export namespace UnsupportedFileNameExtensionErrorMessage {
            export type TemplateVariables = Readonly<{
              filePath: string;
              fileNameLastExtensionWithoutLeadingDot: string;
            }>;
          }

        }
