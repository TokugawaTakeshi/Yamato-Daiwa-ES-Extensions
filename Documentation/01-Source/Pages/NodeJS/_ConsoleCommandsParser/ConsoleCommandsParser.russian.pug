extends ../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../SharedAssets/Markup/SharedAssets.russian.pug
  include ../../../SharedComponents/SharedComponents.russian.pug

  include _ConsoleCommandsParser-DemoCodeViewer.pug


block append Metadata

  -

    HTML_PAGE_LANGUAGE = "ru";
    HTML_PAGE_TITLE = buildHTML_PageTitle("ConsoleCommandsParser");
    HTML_PageMetaData = {
      description: MetaDescriptionTemplates.class({
        className: "ConsoleCommandsParser",
        whatIsClassFor:
            "предназначен для разбора (парсинга) векторов аргументов консольных команд с валидацией и преобразованием их " +
            "к объектным TypeScript-типам. " +
            "Возможно также сгенерировать справочный текст для всех поддерживаемых команд."
      }),
      author: HTML_PAGE_AUTHOR
    };

    FAVICON_URI = "@MustBeInPublicRoot/favicon";

    styleSheetsURIs = [
      "$CommonStyles",
      "$LayoutsStyles/TwoColumns/TwoColumnsLayout.css",
      "$PreMadesStyles",
      "@CustomizedExternalComponents"
    ];

    scriptsURIs.endOfBody = [ "$CommonLogic" ];

    RoutingEmulator.setCurrentRoute("nodeJS.utils.ConsoleCommandsParser");

    LanguageDropDownList__YDF_DK.setLinks({
      english: "./ConsoleCommandsParser.english.html",
      japanese: "./ConsoleCommandsParser.japanese.html"
    });

    const pageTableOfContents = localizedRouting.nodeJS.$children.utils.$children.ConsoleApplicationLogger.$sectioning;


block append HeadScriptsLinks

  if __IS_PRODUCTION_BUILDING_MODE__

    +GoogleAnalyticsScript


block append SpecificContent

  article

    h1.Article-Heading1 Класс #[code ConsoleCommandsParser]

    +CompactTableOfContents--YDF_DK(pageTableOfContents, { mustApplyAnchorsInsteadOfURIs: true })

    p.Article-Paragraph.
      #[+Term--YDID Класс], предназначенный для разбора (#[+Term--YDID парсинга]) #[+Term--YDID векторов аргументов]
        #[+Term__Contrast--YDID консольных команд] с валидацией и преобразованием их к #[+Term--YDID объектным]
        #[+Term__Contrast--YDID TypeScript-типам].
      Возможно также сгенерировать справочный текст для всех поддерживаемых команд.


    //- ━━━ Демо ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: pageTableOfContents.demo.$heading,
      HTML_ID: pageTableOfContents.demo.$anchor
    }).Article-Heading2

    p.Article-Paragraph Нижеследующей пример пример будет полностью разобран.

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true,
      specification: true
    })


    //- ━━━ Минимальные теоретические знания ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: pageTableOfContents.minimalTheory.$heading,
      HTML_ID: pageTableOfContents.minimalTheory.$anchor
    }).Article-Heading2

    p.Article-Paragraph
      | В отношении анатомии #[+Term--YDID консольных команд] официальная терминология и стандарты
      |   #[+Keyword--YDID отсутствуют] — #[+Keyphrase--YDID имеются лишь более-менее устоявшиеся соглашения].
      | В сухом остатке, #[+ImportantEntity__Code--YDID process.argv] (сокращение от #[+Term--YDID «arguments vector»]
      |   — #[+Term--YDID «вектор аргументов»],
      |
      +Link--YDF({
        unendorsedExternalURI: "https://stackoverflow.com/q/3024197/4818123"
      }).Article-Link унаследованная от языка C++ концепция
      | ) — всего лишь #[+Term--YDID массив] #[+Term__Contrast--YDID строк], а что с этими #[+Term--YDID строками]
      |   делать — решает разработчик приложения и/или его заказчики.

    p.Article-Paragraph.
      По сути, разбор #[+Term--YDID консольных команд] — это #[+Keyphrase--YDID частный случай]
        #[+Term--YDID задачи анализа произвольных внешних структурированных данных],
        в котором такими данными будет #[+Term--YDID индексный массив] #[+Term__Contrast--YDID строк], а значит
        #[+Keyword--YDID последовательность] #[+Term--YDID элементов] играет #[+Keyword--YDID ключевое] значение.
      #[+ImportantEntity--YDID Node.js] #[+Keyword--YDID не]&nbsp;предоставляет #[+Keyword--YDID никакой] функциональности
        для разбора таких #[+Term--YDID массивов] и их валидации, а сделать это безопасно (насколько возможно) с точки
        зрения #[+Term--YDID TypeScript-типизации] может ещё и не&nbsp;каждая сторонняя библиотека для работы с
        #[+Term--YDID консольными командами].


    //- ─── Соглашения по терминологии ─────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: pageTableOfContents.minimalTheory.$children.conventionalTerminology.$heading,
      HTML_ID: pageTableOfContents.minimalTheory.$children.conventionalTerminology.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      В общем виде #[+Term--YDID консольная команда] представляет собой последовательность #[+Term--YDID строчных значений],
        разделённых пробелом:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash }).
        команда аргумент1 аргумент2 ... аргументN

    p.Article-Paragraph.
      На примере утилиты #[+SecondaryEntity--YDID Webpack], конкретная команда может иметь вид:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash }).
        webpack build --mode development

    dl.Article-DescriptionList

      dt Команда
      dd.
        По пути, это #[+Term--YDID имя приложения] — полное #[+Keyword--YDID или] сокращённое.
        Например, у консольного интерфейса фреймворка #[+SecondaryEntity--YDID Angular] это
          #[+SecondaryEntity__Code--YDID ng], но чаще #[+Term--YDID команды] либо совпадают с полным именем приложения,
          либо близки к нему, например #[+SecondaryEntity__Code--YDID webpack], #[+SecondaryEntity__Code--YDID gulp],
          #[+SecondaryEntity__Code--YDID lerna].

      dt Опция (option) / Ключ опции (option key)
      dd.
        Начинается с #[+Keyword--YDID двойного] #[+Term--YDID дефиса] (как #[+SecondaryEntity__Code--YDID --mode] в
          примере выше).

      dt Параметр
      dd.
        #[+Term--YDID Значение] #[+Term__Contrast--YDID опции].
        Например, #[+SecondaryEntity__Code--YDID development] является #[+Term--YDID параметром]
          #[+Term__Contrast--YDID опции] #[+SecondaryEntity__Code--YDID --mode].

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.warning, SVG_Icon: true }).
      Из-за несовершенства устоявшейся терминологии, если приведённый выше определения вырвать из контекста
        #[+Term--YDID консольных команд], то они не&nbsp;только потеряют смысл, но внесут огромную путаницу.

    ul.Article-UnorderedList

      li.
        Если #[+Term--YDID опция] #[+Keyword--YDID не]&nbsp;имеет #[+Term__Contrast--YDID параметра], то она
          рассматривается　как #[+Term--YDID опция] #[+Keyword--YDID булевского]　#[+Term__Contrast--YDID типа] со
          значением　#[+ImportantEntity__Code--YDID true].
        Соответственно, когда этой #[+Term--YDID опции] #[+Keyword--YDID не]&nbsp;указано, это
          #[+Keyword--YDID равносильно] значению　#[+ImportantEntity__Code--YDID false].

      li.
        #[+Term--YDID Опция] может иметь сокращение, состоящее из одного #[+Term--YDID дефиса] и одной буквы (например,
          #[+SecondaryEntity__Code--YDID -d]).
        Примечательно, но для приведённого выше в качестве примера #[+SecondaryEntity__Code--YDID webpack]-а сокращение
          #[+SecondaryEntity__Code--YDID -m] имеется, только одно #[+Keyword--YDID не]&nbsp;является сокращением по
          отношению к　#[+SecondaryEntity__Code--YDID --mode].
        Как видно, сокращения хотя и быстры для ввода, но требуют повседневного использования для запоминания.

      li.
        #[+Term--YDID Аргументы] могут иметь пробелы, но при этом они должны быть обёрнуты в кавычки.

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.warning, SVG_Icon: true }).
      Существует также синтаксис
        #[+ImportantEntity__Code--YDID --опция1=параметр1 --опция2=параметр2 ... --опцияN=параметрN].
      На данный момент такой синтаксис #[+Keyword--YDID не]&nbsp;поддерживается
        #[+ImportantEntity--YDID ConsoleCommandsParser], однако если эта поддержка окажется востребована,
        то вероятно её добавление в будущих версиях.

    p.Article-Paragraph.
      Чем же тогда является #[+SecondaryEntity__Code--YDID build] в примере выше?
      Хороший вопрос и он заслуживает отдельного подраздела.


    //- ─── Термин «командная фраза» («command phrase») ────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: pageTableOfContents.minimalTheory.$children.conventionalTerminology.$children.commandPhrase.$heading,
      HTML_ID: pageTableOfContents.minimalTheory.$children.conventionalTerminology.$children.commandPhrase.$anchor
    }).Article-Heading4

    p.Article-Paragraph.
      #[+DefinableTerm--YDID Командная фраза («command phrase»)] — #[+Keyword--YDID первый] #[+Term--YDID аргумент]
        #[+Term--YDID консольной команды], #[+Keyphrase--YDID не&nbsp;являющиеся #[+Term--YDID опцией]] и ссылающийся
        на конкретную функциональность консольного приложения.
      Например, в #[+SecondaryEntity__Code--YDID yda build --mode DEVELOPMENT] #[+Term--YDID командной фразой]
        является #[+SecondaryEntity__Code--YDID build], однако ввиду того, что она #[+Keyword--YDID не]&nbsp;обязана
        состоять из одного слова, она и называется «фразой».
      В случаях, когда #[+Term--YDID командная фраза] состоит из нескольких слов, помимо оборачивания её в кавычки
        можно использовать слитные способы записи нескольких слов, такие как #[+Term--YDID верблюжий регистр].

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice, SVG_Icon: true }).
      Если можно было бы отойти от более-мене устоявшейся терминологии, то логично «команду» назвать
        «приложением», а «командную фразу» — «командой», но главный разработчик #[+ImportantEntity--YDID YDEE] на сей раз
        решил дополнить более-менее устоявшую терминологию несмотря на её запутанность, а не&nbsp;вводить её заново.

    p.Article-Paragraph.
      #[+Term--YDID Командная фраза] может быть явной или неявной (#[+Term--YDID командной фразой по умолчанию]).
      Например, в #[+SecondaryEntity__Code--YDID webpack build --mode development] #[+Term--YDID командная фраза] может
        #[+SecondaryEntity__Code--YDID build] является #[+Term--YDID командной фразой по умолчанию], а потому может
        быть опущена (#[+SecondaryEntity__Code--YDID webpack --mode development]).

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice, SVG_Icon: true }).
      Данный термин введён главным разработчиком #[+ImportantEntity--YDID YDEE].
      Если он используется где-то ещё, значит он был введён независимо, а потому может иметь другой смысл.


    //- ─── Дискриминантное объединение в TypeScript ───────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: pageTableOfContents.minimalTheory.$children.TypeScriptDiscriminatedUnions.$heading,
      HTML_ID: pageTableOfContents.minimalTheory.$children.TypeScriptDiscriminatedUnions.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      Для использования #[+ImportantEntity--YDID ConsoleCommandsParser] необходимо понимать концепцию
        #[+DefinableTerm--YDID дискриминантного объединения] в языке #[+ImportantEntity--YDID TypeScript].
      Суть её в том, что некоторый #[+Term--YDID тип (данных)] может быть #[+Keyphrase--YDID одним из нескольких]
        #[+Keyword--YDID объектных] #[+Term--YDID типов] с #[+Keyword--YDID определённым] набором
        #[+Term--YDID свойств], одно из которых отвечает за #[+Keyword--YDID идентификацию] конкретного
        #[+Term--YDID подтипа].
      Таким образом, #[+Term--YDID дискриминантное объединения] — это #[+Keyword--YDID обобщение] для нескольких
        #[+Keyword--YDID конкретных] #[+Term--YDID объектных типов], подобно тому, как под «легковым автомобилем»
        может подразумеваться «седан», «хэтчбэк», «минивэн» и другие, при этом набор типов в классификации
        #[+Keyword--YDID должен] быть #[+Keyword__Contrast--YDID конечным], а в документации к автомобилю имеется графа
        «тип», благодаря которой можно #[+Keyword--YDID однозначно] сказать, к какому типу принадлежит конкретный
        автомобиль.

    p.Article-Paragraph.
      Рассмотрим это на примере, имеющему отношение #[+ImportantEntity--YDID ConsoleCommandsParser].
      Допустим, разрабатываемая консольная утилита имеет #[+Term__Contrast--YDID командные фразы]
        #[+SecondaryEntity__Code--YDID build], #[+SecondaryEntity__Code--YDID pack],
        #[+SecondaryEntity__Code--YDID deploy] и #[+SecondaryEntity__Code--YDID help].
      Какой именно функциональности приложения они соответствуют — #[+Keyword--YDID сейчас] неважно, однако если для
        пользователей консольного приложения желательны короткие идентификаторы, а для разработчиков — содержательные,
        то можно короткие поместить в #[+Keyword--YDID значение] #[+Term--YDID перечисления]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        enum CommandPhrases {
          projectBuilding = "build",
          packingOfBuild = "pack",
          projectDeploying = "deploy",
          referenceGenerating = "referenceGenerating"
        }

    p.Article-Paragraph.
      Создадим #[+Term--YDID объект] #[+Keyphrase--YDID для каждой] #[+Term--YDID командной фразы], который будет
        включать в себя #[+Term--YDID свойство] #[+SecondaryEntity__Code--YDID phrase] с одним из значений определённого
        выше #[+Term--YDID перечисления] #[+SecondaryEntity__Code--YDID CommandPhrases], а так же #[+Term--YDID опции],
        актуальные для соответствующих #[+Term--YDID командных фраз].
      Пускай все #[+Term--YDID командные фразы], #[+Keyword--YDID кроме] #[+Keyword__Contrast--YDID последней], будут
        иметь #[+Term__Contrast--YDID опции].

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        type ProjectBuildingConsoleCommand = {
          phrase: CommandPhrases.projectBuilding;
          requiredStringOption: string;
          optionalStringOption?: string;
        };

        type PackingOfBuildConsoleCommand = {
          phrase: CommandPhrases.packingOfBuild;
          enumerationLikeStringOption: "FOO" | "BAR" | "BAZ";
          numericOption?: number;
          limitedNumericOption?: number;
        };

        type ProjectDeployingConsoleCommand = {
          phrase: CommandPhrases.projectDeploying;
          booleanOption: boolean;
          JSON5_Option?: Readonly<{ foo: string; bar?: number; }>;
        };

        type ReferenceGeneratingConsoleCommand = {
          phrase: CommandPhrases.referenceGenerating;
        };

    p.Article-Paragraph.
      Какую именно #[+Term--YDID командную фразу] введёт пользователь — мы #[+Keyword--YDID заранее] знать
        #[+Keyword__Contrast--YDID не]&nbsp;можем, однако #[+Keyphrase--YDID при правильно описанных правилах валидации]
        (мы разберём, как это делать) это будет #[+Keyphrase--YDID одна из] приведённых выше #[+Term--YDID командных фраз]
        с соответствующим ей набором #[+Term--YDID опций]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        type SupportedCommandsAndParametersCombinations =
            ProjectBuildingConsoleCommand |
            PackingOfBuildConsoleCommand |
            ProjectDeployingConsoleCommand |
            ReferenceGeneratingConsoleCommand;

    p.Article-Paragraph
      | #[+Term--YDID Метод] #[+ImportantEntity__Code--YDID parse] #[+Term--YDID класса]
      |   #[+ImportantEntity__Code--YDID ConsoleCommandsParser] вернёт #[+Term--YDID объект] определённого выше
      |   #[+Term--YDID типа] #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations] с
      |   #[+Keyword--YDID двумя] #[+Keyword__Contrast--YDID дополнительными] #[+Term--YDID свойствами]:
      |   #[+ImportantEntity__Code--YDID NodeJS_InterpreterAbsolutePath] и
      |   #[+ImportantEntity__Code--YDID executableFileAbsolutePath] — это #[+Keyword--YDID первые]
      |   #[+ImportantEntity--YDID 2] #[+Term--YDID элемента] #[+Term__Contrast--YDID массива]
      |   #[+ImportantEntity__Code--YDID process.argv].
      | По сути, #[+Term--YDID TypeScript-обобщение] #[+ImportantEntity__Code--YDID ParsedCommand] в
      |
      +ImportantEntity__Code--YDID: :html_special_characters_to_html_entities
        ParsedCommand<SupportedCommandsAndParametersCombinations>
      |   сообщает #[+ImportantEntity--YDID TypeScript]-y, что к #[+Keyphrase--YDID одному из] #[+Term--YDID подтипов]
      |   #[+Term__Contrast--YDID объединения] #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations]
      |   будут добавлены эти два #[+Term--YDID свойства]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        const parsedConsoleCommand: ConsoleCommandsParser.
            ParsedCommand<SupportedCommandsAndParametersCombinations> =
            ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

    p.Article-Paragraph.
      Но как мы узнаем, какую именно #[+Term--YDID командную фразу] ввёл пользователь приложения?
      Поскольку у #[+Keyword--YDID всех] #[+Term--YDID подтипов] #[+Term__Contrast--YDID дискриминантного объединения]
        #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations] имеется играющее роль идентификатора
        свойство #[+SecondaryEntity__Code--YDID phrase] с #[+Keyword--YDID уникальными]
        #[+Keyphrase--YDID в пределах этого #[+Term--YDID объединения]] значением, то с помощью
        #[+Term--YDID условных конструкций] (в данном случае идеально подходит
        #[+ImportantEntity__Code--YDID switch/case]) мы можем определить конкретный #[+Term--YDID подтип]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities

        switch (parsedConsoleCommand.phrase) {

          case ApplicationConsoleLineInterface.CommandPhrases.projectBuilding: {
            console.log("Build project");
            console.log(parsedConsoleCommand.requiredStringOption);
            console.log(parsedConsoleCommand.optionalStringOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.packingOfBuild: {
            console.log("Pack build");
            console.log(parsedConsoleCommand.enumerationLikeStringOption);
            console.log(parsedConsoleCommand.numericOption);
            console.log(parsedConsoleCommand.limitedNumericOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.projectDeploying: {
            console.log("Deploy project")
            console.log(parsedConsoleCommand.phrase);
            console.log(parsedConsoleCommand.booleanOption);
            console.log(parsedConsoleCommand.JSON5_Option);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.referenceGenerating: {
            console.log(ConsoleCommandsParser.generateFullHelpReference(ApplicationConsoleLineInterface.specification));
          }

        }

    p.Article-Paragraph.
      В результате, внутри #[+Keyword--YDID каждого] #[+ImportantEntity__Code--YDID case]-блока мы можем обращаться к
        #[+Term--YDID свойствам] #[+SecondaryEntity__Code--YDID parsedConsoleCommand],
        #[+Keyphrase--YDID соответствующим текущей #[+Term--YDID командной фразе]],
        а если попытаться вызывать свойство, ссылающееся на #[+Term--YDID опцию] другой #[+Term--YDID командной фразы],
        #[+ImportantEntity--YDID TypeScript] это заметит в виде ошибки.
      Правда, в примере много #[+Keyword--YDID необязательных] #[+Term--YDID свойств], поэтому перед тем, как ими
        пользоваться, потребуется проверка на #[+ImportantEntity__Code--YDID undefined].


    //- ━━━ Пошаговое руководство по созданию консольного интерфейса ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: pageTableOfContents.stepwiseGuide.$heading,
      HTML_ID: pageTableOfContents.stepwiseGuide.$anchor
    }).Article-Heading2

    //- ─── Шаг 1 — Определение начального набора командных фраз ───────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: pageTableOfContents.stepwiseGuide.$children.initialCommandPhrasesSet.$heading,
      HTML_ID: pageTableOfContents.stepwiseGuide.$children.initialCommandPhrasesSet.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      Решите, какие #[+Term--YDID командные фразы] будут доступны в Вашем приложении.

    ul.Article-UnorderedList

      li.
        Возможно, у Вас будет только одна #[+Term--YDID командная фраза].
        Если Ваше приложение узкоспециализированное, то это вполне нормально.

      li.
        В будущем Вы сможете добавить другие #[+Term--YDID командные фразы], потому на этом этапе можете ограничиться
          теми, назначение которых Вы более-менее осмыслили.

    p.Article-Paragraph.
      Поместите #[+Keyword--YDID все] Ваши #[+Term--YDID командные фразы] в #[+Term__Contrast--YDID перечисление].
      #[+Term--YDID Ключи перечисления] #[+Keyword--YDID не]&nbsp; обязательно должны совпадать с теми последовательностями
        символов, которые пользователь будет вводить в консоль: пускай #[+Term--YDID ключи] лучше будут подлиннее,
        но понятными для программистов #[+Keyphrase--YDID без документации], а если Вы, как и разработчики большинства
        консольных приложений, хотите сделать вводимые #[+Term--YDID командные фразы] короткими, то поместите их в
        #[+Keyword--YDID значения] #[+Term--YDID элементов перечисления].
      К счастью, #[+ImportantEntity--YDID TypeScript] позволяет определять #[+Keyword--YDID строчные]
        #[+Term--YDID перечисления], что невозможно или ограниченно во многих других языках программирования.

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        export enum CommandPhrases {
          projectBuilding = "build",
          packingOfBuild = "pack",
          projectDeploying = "deploy",
          referenceGenerating = "help"
        }

    p.Article-Paragraph.
      Как видно, в данном примере в качестве #[+Term--YDID ключей перечисления] выбраны словосочетания
        #[+Keyword--YDID без]&nbsp;#[+Term--YDID глаголов] — вместо них используются
        #[+Term--YDID отглагольные существительные], потому если наименование начинается с #[+Term--YDID глагола],
        но при этом #[+Keyword--YDID не]&nbsp;принадлежит #[+Term--YDID функции] или #[+Term--YDID методу], то это
        создаёт путаницу.
      Но это это требования стилистические, с которыми Вы можете не&nbsp;согласиться и установить собственные.

    +AdmonitionBlock--YDF({
      title: "Заметка об английской грамматике",
      decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice,
      SVG_Icon: true
    })
      ul.Article-UnorderedList

        li.
          Слово «build» может быть как глаголом, там и существительным, однако за предлогом «of»
            #[+Keyword--YDID не]&nbsp;может идти одиночного глагола, поэтому в примере выше «build» -
            существительное со значением «сборка» («собранный проект»).

        li.
          «Building» может быть существительным, глаголом или причастием, однако в значение существительного
            оно может означать как процесс, так и объект.
          В примере выше, это слово использовано #[+Keyword--YDID только] в значении #[+Keyword__Contrast--YDID процесса],
            а для объекта использовано слово «build» как существительное.

    p.Article-Paragraph.
      Рекомендуется писать этот код в #[+Keyword--YDID отдельном] файле, например
        #[+SecondaryEntity--YDID ApplicationConsoleLineInterface.ts].
      Кроме того, для чёткого определения контекста рекомендуем обернуть всё содержимое этого файла в
        #[+Term--YDID пространство имён], например #[+SecondaryEntity__Code--YDID ApplicationConsoleLineInterface].
      Хотя некоторые разработчики выступают против использование #[+Term--YDID пространств имён] (в
        #[+ImportantEntity--YDID TypeScript]), такое негативное отношение к #[+Term--YDID пространствам имён] обычно
        связано с устаревшими способами разбиения кода на модули, а такое использование, как в нашем примере
        (контекстный контейнер для #[+Term--YDID типов] и #[+Term--YDID констант]) #[+Keyword--YDID не]&nbsp;несёт
        в себе никаких проблем.

    +DemoCodeViewer({ commandPhrasesEnumeration: true })


    //- ─── Шаг 2 — Определение опций для командных фраз ───────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: pageTableOfContents.stepwiseGuide.$children.commandPhrasesOptions.$heading,
      HTML_ID: pageTableOfContents.stepwiseGuide.$children.commandPhrasesOptions.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      Определитесь, какие #[+Term--YDID опции] Вы будете поддерживать #[+Keyphrase--YDID для каждой]
        #[+Term--YDID командной фразы], а также их #[+Term--YDID тип], обязательность и значения по умолчанию
        (если таковые имеются) #[+Keyword--YDID каждой] #[+Term--YDID опции].

    ul.Article-UnorderedList

      li.
        Опять же, для того, чтобы быстрее получить обратную связь от своего кода, #[+Keyphrase--YDID на начальном этапе]
          можно ограничиться минимальным набором #[+Term--YDID опций], наиболее осмысленных во время проектирования.

      li.
        Некоторые #[+Term--YDID командные фразы] могут #[+Keyword--YDID не]&nbsp;иметь #[+Term--YDID опций] — это нормально,
          а если Вы в будущем почувствуете необходимость в #[+Term--YDID опциях], то всегда сможете их добавить.
        В нашем примере #[+Term--YDID опций] #[+Keyword--YDID не]&nbsp;будет у #[+Term--YDID командной фразы]
          #[+SecondaryEntity__Code--YDID referenceGenerating].

    p.Article-Paragraph.
      Теперь, #[+Keyphrase--YDID для каждой] #[+Term--YDID командной фразы] определите
        #[+Term__Contrast--YDID объектный тип] со следующими #[+Term--YDID свойствами]:

    dl.Article-DescriptionList

      dt phrase
      dd.
        #[+Keyword--YDID Должно] содержать #[+Term--YDID элемент перечисления] #[+Term__Contrast--YDID командных фраз]
          (#[+SecondaryEntity__Code--YDID CommandPhrases] в примере выше),
          #[+Keyphrase--YDID соответствующий той же #[+Term--YDID командной фразе]],
          что и #[+Term--YDID тип], который Вы определяете.
        Это #[+Term--YDID свойство] играет роль #[+Keyword--YDID идентификатора], с помощью которого предстоит
          определять, какую именно #[+Term--YDID командную фразу] ввёл пользователь приложения.
        В качестве #[+Term--YDID типа] данного свойства нужно указывать #[+Keyword--YDID не]&nbsp;само
          перечисление (#[+SecondaryEntity__Code--YDID CommandPhrases] в примере выше), а его
          #[+Keyword--YDID конкретный] #[+Term--YDID элемент]
          (например, #[+SecondaryEntity__Code--YDID CommandPhrases.projectBuilding]) — с точки зрения
          #[+Term--YDID дискриминантных объединений] в #[+ImportantEntity--YDID TypeScript] это
          #[+Keyword--YDID не]&nbsp;бессмысленно.

      dt Опции командны
      dd

        p.Article-Paragraph.
          #[+Keyword--YDID Все] #[+Term--YDID опции] для текущей #[+Term--YDID командной фразы].
          #[+Term__Contrast--YDID Ключи] #[+Keyword--YDID не]&nbsp;обязательно должны совпадать с теми, которые
            пользователь будет вводить в консоль, поэтому давайте им такие имена, чтобы их смысл был ясен программистам
            #[+Keyphrase--YDID без документации].
          #[+Term--YDID Тип] #[+Keyword--YDID каждого] из этих #[+Term--YDID свойств] #[+Keyword--YDID должен] быть
            #[+Keyphrase--YDID одним из] следующих поддерживаемых #[+Term--YDID типов]:

        ul.Article-UnorderedList
          li #[+ImportantEntity__Code--YDID string]
          li #[+ImportantEntity__Code--YDID number]
          li #[+ImportantEntity__Code--YDID boolean]
          li
            | #[+Term--YDID Объект] на основе
            |
            +Link--YDF({
              internalURI: localizedRouting.coreLibrary.$children.
                  functionality.$children.
                  types.$children.
                  ParsedJSON_AndRelated.$URI
            }).Article-Link ParsedJSON
            |
            | из #[+Keyword--YDID главного] #[+Term--YDID пакета] (#[+ImportantEntity--YDID @yamato-daiwa/es-extensions])

        p.Article-Paragraph.
          Если же #[+Term--YDID опция] #[+Keyword--YDID необязательная] и
            #[+Keyphrase--YDID при этом #[+Keyword--YDID не]&nbsp; планируется #[+Term--YDID значения по умолчанию]],
            то перед #[+Term--YDID двоеточием] — разделителем #[+Term--YDID ключа] и #[+Term--YDID типа]
            #[+Term__Contrast--YDID значения] — #[+Keyword--YDID необходимо] поставить #[+Term--YDID вопросительный знак].

    p.Article-Paragraph.
      Наконец, объявите #[+Term--YDID TypeScript-объединение], в котором перечислены #[+Keyword--YDID все] только что
        созданные #[+Term--YDID объектные типы] #[+Keyphrase--YDID для каждой] #[+Term__Contrast--YDID командной фразы]
        (в примере ниже это #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations]).

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true
    })

    ul.Article-UnorderedList

      li.
        Снова обращаем Ваше внимание на то, какие могут быть стилистические требования по именованию #[+Term--YDID типов]:
          имя #[+Keyword--YDID каждого] #[+Term--YDID типа], соответствующего конкретной #[+Term--YDID командной фразе],
          #[+Keyword--YDID не]&nbsp;содержит #[+Term--YDID глаголов] и шаблонно заканчивается на
          #[+SecondaryEntity--YDID ConsoleCommand].

      li.
        Использование #[+Term--YDID утилитарного типа] #[+ImportantEntity--YDID Readonly]
          #[+Keyword--YDID не]&nbsp;обязательно, но #[+Keyword--YDID рекомендуется], потому что тем самым мы явно
          выражаем, что #[+Term--YDID свойства] определённых нами #[+Term--YDID объектных типов]
          #[+Keyword--YDID не]&nbsp;подлежат изменениям #[+Keyphrase--YDID в процессе выполнения программы].


    //- ─── Шаг 3 — Определение спецификации консольного приложения ────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: pageTableOfContents.stepwiseGuide.$children.consoleApplicationSpecification.$heading,
      HTML_ID: pageTableOfContents.stepwiseGuide.$children.consoleApplicationSpecification.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      На основе #[+Term--YDID спецификации консольного приложения] будет осуществляться #[+Term--YDID разбор]
        (#[+Term--YDID парсинг]) и #[+Term__Contrast--YDID валидация] введённой #[+Term--YDID консольной команды],
        а при необходимости — генерация справки по использованию этого консольного приложения.

    p.Article-Paragraph.
      Определите #[+Term--YDID константу] #[+Term--YDID типа]
        #[+ImportantEntity__Code--YDID ConsoleCommandsParser.CommandLineInterfaceSpecification] —
        это #[+Keyword--YDID многоуровневый] #[+Term--YDID объект], в котором должна содержатся спецификация
        #[+Keyword--YDID всех] #[+Term--YDID командных фраз] включая #[+Term__Contrast--YDID опции] каждой из них,
        а также данные для генерации справки.
      Если Вы последовали совету обернуть код в #[+Term--YDID пространство имён] такое как
        #[+SecondaryEntity__Code--YDID ApplicationConsoleLineInterface],
        то длинного имени #[+Term--YDID константе] наподобие
        #[+SecondaryEntity__Code--YDID consoleCommandLineInterfaceSpecification]
        #[+Keyword--YDID не]&nbsp;требуется: у нас объявлен #[+Keyword--YDID контекст]
        #[+ImportantEntity--YDID ApplicationConsoleLineInterface], поэтому #[+Term--YDID константу] можно назвать просто
        #[+ImportantEntity__Code--YDID specification].

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true,
      specification: true
    })

    ol.Article-OrderedList

      li.
        #[+Term--YDID Свойству] #[+ImportantEntity__Code--YDID applicationName] укажите имя Вашего приложения.
        Оно #[+Keyword--YDID не]&nbsp;обязано совпадать с вводимым в консоль именем приложения, а если оно состоит
          из нескольких слов, то #[+Keyword--YDID можно] ввести их с разделением пробелом.
        Это значение будет использовано при генерации справки.

      li.
        В отличие от #[+ImportantEntity__Code--YDID applicationName], #[+Term--YDID свойство]
          #[+ImportantEntity__Code--YDID applicationDescription] — описание приложения — #[+Keyword--YDID необязательное],
          тем не&nbsp;менее заполнить его коротким описанием рекомендуется, чтобы сгенерированная справка была
          полноценной.

      li

        | #[+Term--YDID Свойство] #[+ImportantEntity__Code--YDID commandPhrases] должно содержать спецификации
        |   #[+Keyword--YDID каждой] #[+Term--YDID командной фразы].
        | Представляет собой #[+Term--YDID объект] #[+Term__Contrast--YDID типа] #[+Term--YDID «ассоциативный массив»],
        |   #[+Term--YDID ключи] которого #[+Keyword--YDID должны] совпадать с #[+Term--YDID командными фразами].
        | Надёжнее всего с использованием #[+Term--YDID скобочной записи] #[+Keyword--YDID сослать] #[+Term--YDID ключи]
        |   на нужный #[+Term--YDID элемент перечисления] #[+SecondaryEntity__Code--YDID CommandPhrases], например
        |   #[+SecondaryEntity__Code--YDID &lsqb;CommandPhrases.packingOfBuild&rsqb;].
        | Что касается #[+Term--YDID значений] этого #[+Term__Contrast--YDID ассоциативного массива], то:

        ul.Article-UnorderedList

          li.
            Если соответствующая #[+Term--YDID командная фраза] является
              #[+Term__Contrast--YDID командной фразой по умолчанию], то укажите
              #[+Term__Contrast--YDID булевскому свойству] #[+ImportantEntity__Code--YDID isDefault]
              значение #[+ImportantEntity__Code--YDID true].
            Поскольку #[+Term__Contrast--YDID командная фраза по умолчанию] может быть #[+Keyword--YDID только]
              #[+SecondaryEntity__Code--YDID одна], то #[+ImportantEntity__Code--YDID isDefault: true] должно быть
              указано #[+Keyword--YDID максимум] у #[+Keyword__Contrast--YDID одной] #[+Term--YDID командной фразы],
              #[+Keyphrase--YDID иначе выброшено исключение при запуске приложения].

          li.
            Подобно рассмотренному выше #[+ImportantEntity__Code--YDID applicationDescription], для спецификаций
              #[+Term--YDID командных фраз] предусмотрено #[+Term--YDID свойство]
              #[+ImportantEntity__Code--YDID description] — описание #[+Term--YDID командной фразы], которое хотя и
              #[+Keyword--YDID не]&nbsp;обязательно, но #[+Keyword__Contrast--YDID настоятельно]
              #[+Keyword--YDID рекомендуется] указать, чтобы сгенерировалась качественная справка.
            В примере выше описание пропущено лишь у #[+Term--YDID командной фразы] #[+SecondaryEntity__Code--YDID help]
              (#[+SecondaryEntity__Code--YDID CommandPhrases.referenceGenerating]).

          li.
            Если у #[+Term--YDID командной фразы] есть #[+Term--YDID опции], то их спецификацию необходимо указать
              в #[+Term--YDID свойстве] #[+ImportantEntity__Code--YDID options], которое также представляет собой
              #[+Term--YDID объект] типа #[+Term--YDID «ассоциативный массив»].

    //- ─── Определение опций командных фраз ───────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: pageTableOfContents.
          stepwiseGuide.$children.consoleApplicationSpecification.$children.optionsSpecification.$heading,
      HTML_ID: pageTableOfContents.
          stepwiseGuide.$children.consoleApplicationSpecification.$children.optionsSpecification.$anchor
    }).Article-Heading4

    p.Article-Paragraph.
      Большую часть времени этого этапа займёт именно определение #[+Term--YDID опций] #[+Term__Contrast--YDID комадных фраз],
        если таковых много.
      Сложного, однако, ничего нет: через #[+Term--YDID ключи] #[+Term__Contrast--YDID объекта]
        #[+Keyword--YDID необходимо] перечислить #[+Term--YDID опции] такими, какими они будут введены, а через
        #[+Term--YDID значения] (#[+Keyword--YDID тоже] #[+Keyword__Contrast--YDID объектного] #[+Term--YDID типа]) —
        настройки этих #[+Term--YDID опций], такие как #[+Term--YDID тип], обязательность и так далее.

    ol.Article-OrderedList

      li.
        Укажите #[+Term--YDID тип] #[+Term__Contrast--YDID опции] в виде #[+Term--YDID элемента перечисления]
          #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes].
        На данный момент поддерживаются #[+Keyword--YDID строчные], #[+Keyword--YDID числовые] и
          #[+Keyword--YDID булевские] #[+Term--YDID опции], а так же в формате #[+ImportantEntity--YDID JSON5].

      li.
        Если #[+Term--YDID опция] имеет значение по умолчанию, то укажите значение #[+Keyword--YDID соответствующего]
          #[+Term--YDID типа] свойству #[+ImportantEntity__Code--YDID defaultValue].
        #[+Keyphrase--YDID В противном случае], #[+Keyword--YDID необходимо] #[+Keyword__Contrast--YDID явно] указать
          #[+Keyword--YDID булевское] #[+Term--YDID свойство] #[+ImportantEntity__Code--YDID required]
          (#[+ImportantEntity__Code--YDID true] — если #[+Term--YDID опция] обязательна).
        При этом для #[+Keyword--YDID необязательной] #[+Keyword__Contrast--YDID булевской] #[+Term--YDID опции]
          указать #[+ImportantEntity__Code--YDID defaultValue] #[+Keyword--YDID нельзя], поскольку
          #[+Keyword--YDID не]&nbsp;введённое значение #[+Keyword--YDID равносильно] #[+Keyword--YDID false].
      //- TODO ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      li.
        Если Вы хотите работать с более понятным именем опции, при этом оставить возможность пользователю вводить
          короткое, хоть и неясное имя опции, то определите свойство #[+ImportantEntity__Code--YDID newName].

      li.
        Если Вы хотите определить для #[+Term--YDID опции] однобуквенное сокращение, то определите его через
          свойство #[+ImportantEntity__Code--YDID shortcut].
        Дефис, который пользователь должен будет указать при использование этого сокращения, здесь, при определении,
          указывать #[+Keyword--YDID не]&nbsp;нужно.

    p.Article-Paragraph.
      Все остальные аттрибуты зависят от типа опции.
      Рассмотрим их.


    h5.Article-Heading5 Специальные аттрибуты строчных опций

    p.Article-Paragraph.
      На данный момент такой аттрибут только один — #[+ImportantEntity__Code--YDID allowedAlternatives].
      Если Вы хотите, чтобы строковая #[+Term--YDID опция] могла принимать только определённые значения, то укажите
        их в виде #[+Term--YDID массива] #[+Term__Contrast--YDID свойству]
        #[+ImportantEntity__Code--YDID allowedAlternatives].


    h5.Article-Heading5 Специальные аттрибуты числовых опций

    dl.Article-DescriptionList

      dt #[+ImportantEntity__Code--YDID numbersSet]
      dd

        | #[+Term--YDID Множество чисел], #[+Keyword--YDID обязательный] аттрибут для данного типа
        | Его значением должен быть один из #[+Term--YDID элементов перечисления], заимствованного из главного пакета —
        |  #[+ImportantEntity__Code--YDID RawObjectDataProcessor.NumbersSets].

        dl.Article-DescriptionList
          dt #[+ImportantEntity__Code--YDID naturalNumber]
          dd Натуральное число

          dt #[+ImportantEntity__Code--YDID nonNegativeInteger]
          dd Неотрицательное целое число

          dt #[+ImportantEntity__Code--YDID negativeInteger]
          dd Отрицательное целое число

          dt #[+ImportantEntity__Code--YDID negativeIntegerOrZero]
          dd Отрицательное целое число либо ноль

          dt #[+ImportantEntity__Code--YDID anyInteger]
          dd Любое целое число

          dt #[+ImportantEntity__Code--YDID positiveDecimalFraction]
          dd Положительная десятичная дробь

          dt #[+ImportantEntity__Code--YDID negativeDecimalFraction]
          dd Отрицательная десятичная дробь

          dt #[+ImportantEntity__Code--YDID decimalFractionOfAnySign]
          dd Любая десятичная дробь

          dt #[+ImportantEntity__Code--YDID anyRealNumber]
          dd Любое действительное число

      dt #[+ImportantEntity__Code--YDID minimalValue]
      dd Минимальное значение

      dt #[+ImportantEntity__Code--YDID maximalValue]
      dd Максимальное значение


    h5.Article-Heading5 Специальные аттрибуты объектных опций

    p.Article-Paragraph.
      На данный момент такой аттрибут только #[+Keyword--YDID один], но #[+Keyword__Contrast--YDID обязательный] —
        #[+ImportantEntity__Code--YDID validValueSpecification].
      С помощью него необходимо задать правила валидации #[+Term--YDID объекта], в который будет преобразована
        #[+Term--YDID строка] формата #[+ImportantEntity--YDID JSON5].

    p.Article-Paragraph
      | Это #[+Term--YDID свойство] имеет #[+Term--YDID тип]
      |
      +Link--YDF({
        endorsedExternalURI: localizedRouting.coreLibrary.$children.
            functionality.$children.
            RawObjectDataProcessor.$sectioning.
            API.$children.
            types.$children.
            PropertiesSpecification.$URI
      }).Article-Link PropertiesSpecification
      |   , заимствованный из #[+ImportantEntity--YDID RawObjectDataProcessor] основного пакета.
      | Это #[+Keyword--YDID объектное] #[+Term--YDID свойство] очень похоже на спецификацию опций
      |   #[+Term--YDID командной фразы], только вместо #[+Term--YDID опций] — ключи объекта, а спецификация каждого
      |   свойства может быть гораздо более гибкой, в соответствии с #[+Term--YDID API]
      |   #[+ImportantEntity--YDID RawObjectDataProcessor].


    h3.Article-Heading3 Шаг 4 — Создание логики разбора консольных команд

    p.Article-Paragraph.
      На этом определение спецификации консольного приложения завершено; теперь её можно использовать при разборе
        введённой #[+Term--YDID консольной команды].
      Для этого необходимо у класса #[+ImportantEntity--YDID ConsoleCommandsParser] вызывать
        #[+Term--YDID статический метод] #[+ImportantEntity__Code--YDID parse]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        import { ConsoleCommandsParser } from "@yamato-daiwa/es-extensions-nodejs";
        import ApplicationConsoleLineInterface from "./ConsoleLineInterface";

        const parsedConsoleCommand: ConsoleCommandsParser.
            ParsedCommand<ApplicationConsoleLineInterface.SupportedCommandsAndParametersCombinations> =
            ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

    p.Article-Paragraph.
      #[+Keyword--YDID Обязательным] #[+Term--YDID параметром] этого метода является спецификация
        консольного приложения, которую Вы определили на предыдущем шаге.
      Если #[+Keyword--YDID не]&nbsp;указывать #[+ImportantEntity--YDID 2го] #[+Term--YDID параметра], то
        #[+Term--YDID вектор аргументов] будет взят из #[+ImportantEntity__Code--YDID process.argv].
      Также, в качестве #[+Term--YDID параметра обобщения] #[+Keyword--YDID необходимо] указать
        #[+Term--YDID TypeScript-объединение] #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations],
        которое мы определили ранее.

    p.Article-Paragraph.
      Теперь нам нужно определить, какая именно #[+Term--YDID командная фраза] была введена, а также безопасно
        (без ошибок #[+ImportantEntity--YDID TypeScript]) обратиться к её #[+Term--YDID опциям] (разве что
        в случае #[+Keyword--YDID необязательными] #[+Term--YDID опциями] всё же потребуется проверка на
        #[+ImportantEntity__Code--YDID undefined], прежде чем ими полноценно пользоваться).
      Сделать это можно с помощью #[+ImportantEntity__Code--YDID switch/case]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        switch (parsedConsoleCommand.phrase) {

          case ApplicationConsoleLineInterface.CommandPhrases.projectBuilding: {
            console.log("Build project", parsedConsoleCommand);
            console.log("requiredStringOption", parsedConsoleCommand.requiredStringOption);
            console.log("optionalStringOption", parsedConsoleCommand.optionalStringOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.packingOfBuild: {
            console.log("Pack project", parsedConsoleCommand);
            console.log("enumerationLikeStringOption", parsedConsoleCommand.enumerationLikeStringOption);
            console.log("numericOption", parsedConsoleCommand.numericOption);
            console.log("limitedNumericOption", parsedConsoleCommand.limitedNumericOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.projectDeploying: {
            console.log("Deploy project", parsedConsoleCommand);
            console.log("booleanOption", parsedConsoleCommand.booleanOption);
            console.log("JSON5_Option", parsedConsoleCommand.JSON5_Option);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.referenceGenerating: {
            console.log(ConsoleCommandsParser.generateFullHelpReference(ApplicationConsoleLineInterface.specification));
          }

        }


    h3.Article-Heading3 Шаг 5 — Обеспечение запуска приложения по имени

    p.Article-Paragraph
      | На данный момент приложение уже можно запускать по пути файла с помощью
      |
      +Link--YDF({ unendorsedExternalURI: sharedExternalLinks.tsNode.homePage.top }).Article-Link ts-node
      |   , например:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        ts-node EntryPoint.test.ts --requiredStringOption test --optionalStringOption sample

    p.Article-Paragraph.
      Хотя такой вариант многих не&nbsp;устроит, рассмотрим вкратце, когда он подходит и на завершённых предыдущих этапах
        можно остановиться.
      Прежде всего это случаи, когда разрабатываемый #[+Term--YDID консольный интерфейс] планируется применять
        #[+Keyword--YDID исключительно] в рамках одного проекта #[+Keyword--YDID без]&nbsp;публикации в
        #[+ImportantEntity--YDID npm] или другими способами.
      Частыми являются следующие сценарии:

    dl.Article-DescriptionList

      dt Серверное приложение
      dd.
        Как правило, в таких приложениях одна #[+Term--YDID командная фраза] для запуска сервера, а через опции передаются
          #[+Term--YDID HTTP-порт], уровень логирования и так далее.

      dt Скрипты для автоматизации
      dd.
        Обычно это генерация, копирование или модификация файлов, причём задача насколько специфическая, что средства
          общего назначения, такие как #[+ImportantEntity--YDID Gulp], не&nbsp;подходят.
        Например, при создании демо для #[+Term--YDID GUI-компонентов] в
          #[+ImportantEntity__Code--YDID @yamato-daiwa/frontend] был написан скрипт, позволяющий генерировать
          #[+Term--YDID Pug-файлы], содержащие демонстрацию конкретной особенности компонента на основе определённых
          исходных файлов (правда из-за того, что скрипт принимает всего один #[+Term--YDID аргумент] через консоль,
          рассчитанный на более сложные случае #[+ImportantEntity__Code--YDID ConsoleCommandsParser] не&nbsp;потребовался).

    p.Article-Paragraph.
      Но как же всё-таки сделать возможным вызов утилиты по имени, подобно #[+ImportantEntity--YDID gulp],
        #[+ImportantEntity--YDID webpack] и так далее?
      Во-первых, поскольку #[+Term--YDID рантайм] #[+ImportantEntity--YDID Node.js] #[+Keyword--YDID не]&nbsp;поддерживает
        #[+ImportantEntity--YDID TypeScript], то сначала нужно обеспечить #[+Term--YDID транспайлинг] исходного кода в
        #[+ImportantEntity--YDID JavaScript].
      Сделать это можно как и средствами #[+ImportantEntity--YDID CLI] языка #[+ImportantEntity--YDID TypeScript],
        так и с помощью сторонних утилит, таких как тот же самый #[+ImportantEntity__Code--YDID Webpack].

    p.Article-Paragraph.
      Однако перед тем, как запускать транспайлинг, необходимо импортировать из #[+Term--YDID точки входа]
        #[+Term__Contrast--YDID функцию] или же #[+Term--YDID класс], один из #[+Term--YDID методов] которого приведёт
        к запуску приложения.
      Вот пример точки входа, которая импортирует функцию #[+ImportantEntity__Code--YDID executeApplication]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        import { ConsoleCommandsParser } from "@yamato-daiwa/es-extensions-nodejs";
        import ApplicationConsoleLineInterface from "./ConsoleLineInterface";


        export function executeApplication(): void {

          const parsedConsoleCommand: ConsoleCommandsParser.
              ParsedCommand<ApplicationConsoleLineInterface.SupportedCommandsAndParametersCombinations> =
              ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

          switch (parsedConsoleCommand.phrase) {

            case ApplicationConsoleLineInterface.CommandPhrases.projectBuilding: {
              // ...
              break;
            }

            case ApplicationConsoleLineInterface.CommandPhrases.packingOfBuild: {
              // ...
              break;
            }

            case ApplicationConsoleLineInterface.CommandPhrases.projectDeploying: {
              // ...
              break;
            }

            case ApplicationConsoleLineInterface.CommandPhrases.referenceGenerating: {
              console.log(ConsoleCommandsParser.generateFullHelpReference(ApplicationConsoleLineInterface.specification));
            }

          }

        }

    p.Article-Paragraph.
      Выполнив преобразование #[+Keyword--YDID исходного] кода в #[+ImportantEntity--YDID JavaScript], создайте ещё
        один #[+Keyword--YDID JavaScript]-файл (скажем, #[+SecondaryEntity--YDID Executable.js]) вручную с содержимым
        подобным следующему:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JavaScript
      }): :html_special_characters_to_html_entities
        #!/usr/bin/env node

        require("./EntryPoint").executeApplication();

    p.Article-Paragraph.
      Здесь первая строка содержит #[+Term--YDID шебанг], указывающий на то, что этот файл необходимо выполнять с помощью
        #[+ImportantEntity--YDID Node.js].
      Далее следует импортировать функцию, запускающую приложение (#[+SecondaryEntity__Code--YDID executeApplication]
        в примере выше) и вызвать её.

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice, SVG_Icon: true }).
      Такая организация с #[+Term--YDID импортированием] #[+Term__Contrast--YDID функции] и вызовом ещё в
        #[+Term--YDID исполняемом файле] #[+Keyword--YDID не]&nbsp;является единственной возможной,
        но как вариант имеет право на существование.
      Цель — обеспечить выполнение кода, находящегося в #[+Term--YDID точке входа] при её #[+Term--YDID импорте]
        в #[+Term--YDID исполняемый файл].

    p.Article-Paragraph.
      Последний шаг — указание в #[+ImportantEntity--YDID package.json] #[+Term--YDID поля]
        #[+ImportantEntity__Code--YDID bin].
      Для того, чтобы утилита была доступна по имени, это поле необходимо заполнить #[+Term--YDID объектом]
        #[+Term__Contrast--YDID типа] #[+Term--YDID «ассоциативный массив»], #[+Keyword--YDID ключами] которого будут
        #[+Keyword--YDID команды], а значениями - #[+Keyword--YDID относительные] пути к соответствующим
        #[+Term--YDID исполняемым файлам] (расширение #[+ImportantEntity--YDID «.js»] #[+Keyword--YDID можно] опустить).

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON
      }): :html_special_characters_to_html_entities
        {
          // ...
          "bin": {
            "my_app": "Executable"
          },
          // ...
        }

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice, SVG_Icon: true }).
      Напомним, что согласно запутанной, но более-менее устоявшейся терминологии, #[+Term--YDID команда] — это
        #[+Keyphrase--YDID имя приложения, которое вводится в консоль в первую очередь]
        (наподобие #[+SecondaryEntity--YDID gulp] или #[+SecondaryEntity--YDID webpack]), а
        #[+Keyword--YDID не]&nbsp;#[+Term--YDID командная фраза].

    p.Article-Paragraph
      | Более подробную информацию о #[+Term--YDID поле] #[+ImportantEntity__Code--YDID «bin»] Вы можете получить в
      |
      +Link--YDF({
        unendorsedExternalURI: sharedExternalLinks.npm.packageJSON.bin
      }).Article-Link официальной документации npm
      | .

    p.Article-Paragraph.
      Теперь, если Вы установите этот проект с консольным приложением в другой как #[+Term--YDID зависимость] (для этого
        #[+Keyphrase--YDID не]&nbsp;обязательно публиковать его в #[+ImportantEntity--YDID npm]), то консольная утилита
        будет доступна для вызова по тому имени, что Вы указали через #[+Keyword--YDID ключ]
        #[+Term--YDID ассоциативного массива] #[+ImportantEntity__Code--YDID bin] в #[+ImportantEntity--YDID package.json].
      Если же Вы планируете опубликовать утилиту в #[+ImportantEntity--YDID npm], то помимо
        #[+ImportantEntity__Code--YDID bin] потребуется заполнить и некоторые другие поля в
        #[+ImportantEntity--YDID package.json].


    h2.Article-Heading2 Программный интерфейс класса ConsoleCommandsParser (API)

    p.Article-Paragraph.
      Все открытые методы и поля класса являются статическими, создание экземпляра класса без ошибок TypeScript
        невозможно.

    h3.Article-Heading3 Статические методы

    +CallableExpressionScheme--YDF_DK({
      technicalName: "parse",
      localizedDescriptiveHeading: "Проанализировать (консольную команду)",
      genericParameters: [
        {
          name: "TargetCommandsAndOptionsCombinations",
          extends: "ConsoleCommandsParser.GeneralizedCommandsAndOptionsCombinations"
        }
      ],
      parametersSpecification: [
        {
          genericTechnicalName: "commandLineInterfaceSpecification",
          localizedName: "Спецификация консольной команды",
          type: "ConsoleCommandsParser.CommandLineInterfaceSpecification",
          required: true
        },
        {
          genericTechnicalName: "argumentsVector",
          localizedName: "Вектор аргументов",
          type: "Array<string>",
          defaultValue: "process.argv"
        }
      ],
      returnedValue: "ConsoleCommandsParser.ParsedCommand<TargetCommandsAndOptionsCombinations>",
      headingTag: "h4"
    })

    p.Article-Paragraph.
      Анализирует #[+Term--YDID вектор аргументов] (по умолчанию #[+ImportantEntity__Code--YDID process.argv]) в
        соответствии со #[+Term--YDID спецификацией консольной команды], переданной через #[+Keyword--YDID первый]
        #[+Term--YDID параметр], и если #[+Term--YDID вектор аргументов] соответствует спецификации, то возвращает
        #[+Term--YDID объект], включающий в себя #[+Term--YDID опции консольной команды].

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        import { ConsoleCommandsParser } from "@yamato-daiwa/es-extensions-nodejs";
        import ApplicationConsoleLineInterface from "./ConsoleLineInterface";

        const parsedConsoleCommand: ConsoleCommandsParser.
            ParsedCommand<ApplicationConsoleLineInterface.SupportedCommandsAndParametersCombinations> =
            ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

    p.Article-Paragraph.
      Прежде, чем вызывать этот #[+Term--YDID метод], следует выполнить подготовительные работы, включающие в себя:

    ol.Article-OrderedList
      li.
        Проектирование #[+Term--YDID консольного интерфейса], заключающееся в принятии решений о том, какие
          будут в приложении #[+Term--YDID командные фразы] и соответствующие им #[+Term--YDID опции].
      li.
        Определение #[+Term--YDID дискриминантного объединения], #[+Keyword--YDID каждая] составляющая которого
          соответствует #[+Keyword--YDID конкретной] #[+Term--YDID командной фразе] и содержащей в себе
          #[+Term--YDID опции], #[+Keyphrase--YDID актуальные для этой #[+Term--YDID командной фразы]].
        Это #[+Term--YDID дискриминантное объединение] предстоит передать в качестве #[+Term--YDID параметра обобщения]
          #[+Term__Contrast--YDID метода] #[+ImportantEntity__Code--YDID parse].

      li.
        Определение #[+Term--YDID спецификации консольного приложения], в которой необходимо указать правила валидации
          #[+Term--YDID опций] для каждой #[+Term--YDID командной фразы], а также рекомендуется указать описания
          приложения в целом, #[+Term--YDID командных фраз] и #[+Term--YDID опций], чтобы можно было сгенерировать
          качественную справку.
        Эту #[+Term--YDID спецификации консольного приложения] предстоит передать в качестве #[+Keyword--YDID первого]
          #[+Term--YDID параметра] #[+Term--YDID метода] #[+ImportantEntity__Code--YDID parse].

    p.Article-Paragraph.
      Выше был разобран следующий пример выполнения этих подготовительных шагов:

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true,
      specification: true
    })


    h5.Article-Heading5 Параметр обобщения

    p.Article-Paragraph.
      Должен быть #[+Term--YDID дискриминантным объединением], #[+Keyword--YDID каждая] составляющая которого должна:

    ul.Article-UnorderedList

      li Соответствовать #[+Keyword--YDID конкретной] #[+Term--YDID командной фразе].

      li.
        Иметь #[+Term--YDID свойство], #[+Keyword--YDID однозначно] идентифицирующее #[+Term--YDID командную фразу],
          #[+Term__Contrast--YDID ключ] которого (например, #[+SecondaryEntity__Code--YDID phrase])
          #[+Keyphrase--YDID #[+Keyword--YDID общий] для всех составляющих], однако #[+Term--YDID значение]
          #[+Keyphrase--YDID в рамках #[+Term--YDID дискриминантного объединения]] #[+Keyword--YDID должно] быть
          #[+Keyword__Contrast--YDID уникальным].
        Чтобы гарантировать эту уникальность, можно, как показано в примере ниже, заготовить #[+Term--YDID перечисление]
          для всех #[+Term--YDID командных фраз] и указывать его #[+Term--YDID элемент] в качестве значения
          идентифицирующего свойства.

      li.
        Иметь #[+Term--YDID свойства], соответствующие той же #[+Term__Contrast--YDID командной фразе],
          что и идентифицирующее свойство.
        Если #[+Term--YDID опция] необязательная,
          #[+Keyphrase--YDID при этом #[+Keyword--YDID не]&nbsp;имеет значения по умолчанию],
          то #[+Keyword--YDID соответствующее] #[+Term--YDID TypeScript-свойство] #[+Keyword__Contrast--YDID необходимо]
          пометить символом #[+ImportantEntity__Code--YDID ?] после имени свойства.

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true
    })


    h5.Article-Heading5 Параметры

    h6.Article-Heading6 specification — Спецификация консольного приложения

    +ObjectTypeAbstract--YDF_DK({
      typeName: "ConsoleCommandsParser.CommandLineInterfaceSpecification",
      localizedDescriptiveHeading: "Спецификация консольной команды",
      propertiesSpecification: {
        applicationName: {
          localizedInterpretation: "Имя приложения",
          type: "string",
          required: true
        },
        applicationDescription: {
          localizedInterpretation: "Описание приложения",
          type: "string",
          required: false
        },
        commandPhrases: {
          localizedInterpretation: "Спецификация командных фраз",
          type: "{ [commandPhrase: string]: ConsoleCommandsParser.CommandPhraseSpecification; }",
          required: true
        }
      }
    })

    p.Article-Paragraph.
      #[+Keyword--YDID Многоуровневый] #[+Term--YDID объект], включающий в себя информацию о
        #[+Term--YDID консольном приложении] в целом, спецификацию #[+Term--YDID командных фраз] и
        #[+Term--YDID опций] для каждой из них.
      Используется для анализа #[+Term--YDID вектора аргументов], их валидации, а так же генерирования справки по
        использованию #[+Term--YDID консольного приложения].

    p.Article-Paragraph.
      #[+Keyword--YDID Верхний] уровень включает в себя #[+ImportantEntity--YDID 3] #[+Term--YDID свойства]:

    dl.Article-DescriptionList

      dt #[+ImportantEntity__Code--YDID applicationName]
      dd.
        Имя приложения.
        Используется при бросании #[+Term--YDID исключений], потому является обязательным.

      dt #[+ImportantEntity__Code--YDID applicationDescription]
      dd.
        Описание приложения.
        Используется исключительно для генерации справки.
        Хотя справка может быть сгенерирована и без этого #[+Term--YDID свойства], для повышения качества справки
          рекомендуется в одно-два предложения объяснить, для чего предназначено приложение.

      dt #[+ImportantEntity__Code--YDID commandPhrases]
      dd.
        Спецификация #[+Term--YDID командных фраз].
        #[+Term--YDID Объект] типа #[+Term__Contrast--YDID «ассоциативный массив»], #[+Keyword--YDID ключами] которого
          являются #[+Term--YDID командные фразы] #[+Keyphrase--YDID в таком виде, в каком их вводят в консоль].
        #[+Term--YDID Значениями] же являются #[+Term--YDID объекты] нижеследующего #[+Term--YDID типа].

    +ObjectTypeAbstract--YDF_DK({
      typeName: "ConsoleCommandsParser.CommandPhraseSpecification",
      localizedDescriptiveHeading: "Спецификация командной фразы",
      propertiesSpecification: {
        isDefault: {
          localizedInterpretation: "Является ли командной фразой по умолчанию",
          type: "boolean",
          required: false
        },
        description: {
          localizedInterpretation: "Описание (командной фразы)",
          type: "string",
          required: false
        },
        options: {
          localizedInterpretation: "Спецификация опцией командной фразы",
          type: "{ [optionKey: string]: ConsoleCommandsParser.OptionSpecification; }",
          required: false
        }
      }
    })

    dl.Article-DescriptionList

      dt #[+ImportantEntity__Code--YDID isDefault]
      dd.
        Является ли #[+Term--YDID командной фразой] #[+Keyphrase--YDID по умолчанию].
        Поскольку двух и более #[+Term--YDID командных фраз] по умолчанию быть #[+Keyword--YDID не]&nbsp;может,
          то если #[+ImportantEntity__Code--YDID { isDefault: true }]&nbsp;указано для двух и более
          #[+Term--YDID командных фраз], то #[+Keyphrase--YDID будет выброшено #[+Term--YDID исключение]].

      dt #[+ImportantEntity__Code--YDID description]
      dd.
        Описание #[+Term--YDID командной фразы].
        Используется исключительно для генерации справки.
        Хотя справка может быть сгенерирована и без этого #[+Term--YDID свойства], для повышения качества справки
          рекомендуется в одно-два предложения объяснить, какой функциональности соответствует
          #[+Term--YDID командная фразы].

      dt #[+ImportantEntity__Code--YDID options]
      dd.
        Спецификация #[+Term--YDID опций] #[+Term__Contrast--YDID командной фразы].
        #[+Term--YDID Объект] типа #[+Term__Contrast--YDID «ассоциативный массив»], #[+Keyword--YDID ключами] которого
          являются #[+Term--YDID ключи опций] #[+Keyphrase--YDID в таком виде, в каком их вводят в консоль].
        #[+Term--YDID Значениями] же являются #[+Term--YDID объекты] #[+Keyword--YDID полиморфного] #[+Term--YDID типа]
          #[+ImportantEntity__Code--YDID ConsoleCommandsParser.OptionSpecification].

    p.Article-Paragraph.
      #[+Keyphrase--YDID Вне зависимости от типа #[+Term--YDID опции]],
        #[+ImportantEntity__Code--YDID ConsoleCommandsParser.OptionSpecification] имеет следующие #[+Term--YDID свойства]:

    dl.Article-DescriptionList

      dt #[+ImportantEntity__Code--YDID description]
      dd.
        Описание #[+Term--YDID опции] #[+Term__Contrast--YDID командной фразы].
        Используется исключительно для генерации справки.
        Хотя справка может быть сгенерирована и без этого #[+Term--YDID свойства], для повышения качества справки
          рекомендуется в одно-два предложения объяснить, на что влияет данная #[+Term--YDID опция].

      dt #[+ImportantEntity__Code--YDID shortcut]
      dd.
        #[+Keyword--YDID Необязательное] #[+Keyword__Contrast--YDID однобуквенное] сокращение #[+Term--YDID ключа опции].
        Дефис указывать #[+Keyword--YDID не]&nbsp;обязательно.

      dt #[+ImportantEntity__Code--YDID newName]
      dd.
        Имя, под которым #[+Term--YDID опция] будет доступна по результатам разбора команды.
        Если в качестве ключей в #[+Term--YDID ассоциативном массиве]
          #[+ImportantEntity__Code--YDID options] #[+Keyword--YDID необходимо] указывать именно те строки,
          которые будут введены в консоль, то #[+Term--YDID свойство] #[+ImportantEntity__Code--YDID newName]
          этот ключ переименовать в более удобную для разработчиков последовательность символов.
        Если же переименование не&nbsp;требуется, то #[+ImportantEntity__Code--YDID newName] можно
          #[+Keyword--YDID не]&nbsp;указывать.

    p.Article-Paragraph.
      Остальные #[+Term--YDID свойства] зависят от конкретного типа #[+Term--YDID опции], который указывается через
        #[+Term--YDID свойство] #[+ImportantEntity__Code--YDID type].
      По сути, #[+ImportantEntity__Code--YDID ConsoleCommandsParser.OptionSpecification] является
        #[+Term--YDID дискриминантным объединением], где #[+ImportantEntity__Code--YDID type] —
        #[+Term--YDID идентифицирующее свойство], значением которого должен быть один из
        #[+Term--YDID элементов перечисления] #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes].

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :html_special_characters_to_html_entities
        export type OptionSpecification =
            Readonly<{
              description?: string;
              shortcut?: string;
            }> &
            (
              StringOptionSpecification |
              NumberOptionSpecification |
              BooleanParameterSpecification |
              JSON5_ParameterSpecification
            );

    dl.Article-DescriptionList

      dt #[+ImportantEntity__Code--YDID StringOptionSpecification]
      dd

        | Спецификация #[+Keyword--YDID строчной] #[+Term--YDID опции].

        dl.Article-DescriptionList

          dt #[+ImportantEntity__Code--YDID type]
          dd.
            Для выполнения корректной валидации (как статической с помощью #[+ImportantEntity--YDID TypeScript], так и
              динамической), для #[+Keyword--YDID строчной] #[+Term--YDID опции] должно быть указано значение
              #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes.string]
              #[+Keyphrase--YDID и ничего другого].

          dt #[+ImportantEntity__Code--YDID allowedAlternatives]
          dd #[+Keyword--YDID Массив] допустимых значений.


      dt #[+ImportantEntity__Code--YDID NumberOptionSpecification]
      dd

        | Спецификация #[+Keyword--YDID числовой] #[+Term--YDID опции].

        dl.Article-DescriptionList

          dt #[+ImportantEntity__Code--YDID type]
          dd.
            Для выполнения корректной валидации (как статической с помощью #[+ImportantEntity--YDID TypeScript], так и
              динамической), для #[+Keyword--YDID числовой] #[+Term--YDID опции] должно быть указано значение
              #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes.number]
              #[+Keyphrase--YDID и ничего другого].


          dt #[+ImportantEntity__Code--YDID numbersSet]
          dd

            | #[+Term--YDID Множество чисел], которому должно удовлетворять введённое значение.
            | #[+Keyword--YDID Обязательно] для указания, поскольку от этого зависит алгоритм преобразования
            |   #[+Keyword--YDID строчного] значения (а #[+Term--YDID вектор аргументов] — это #[+Term--YDID массив]
            |   #[+Keyword--YDID строк]) в #[+Term--YDID число].
            | Должно быть #[+Term--YDID элементом перечисления]
            |   #[+ImportantEntity__Code--YDID RawObjectDataProcessor.NumbersSets], заимствованного из
            |   #[+Term--YDID класса] #[+ImportantEntity__Code--YDID RawObjectDataProcessor] основного пакета:

            dl.Article-DescriptionList

              dt #[+ImportantEntity__Code--YDID naturalNumber]
              dd Натуральное число

              dt #[+ImportantEntity__Code--YDID nonNegativeInteger]
              dd Неотрицательное целое число

              dt #[+ImportantEntity__Code--YDID negativeInteger]
              dd Отрицательное целое число

              dt #[+ImportantEntity__Code--YDID negativeIntegerOrZero]
              dd Отрицательное целое число либо ноль

              dt #[+ImportantEntity__Code--YDID anyInteger]
              dd Любое целое число

              dt #[+ImportantEntity__Code--YDID positiveDecimalFraction]
              dd Положительная десятичная дробь

              dt #[+ImportantEntity__Code--YDID negativeDecimalFraction]
              dd Отрицательная десятичная дробь

              dt #[+ImportantEntity__Code--YDID decimalFractionOfAnySign]
              dd Любая десятичная дробь

              dt #[+ImportantEntity__Code--YDID anyRealNumber]
              dd Любое действительное число

              dt #[+ImportantEntity__Code--YDID minimalValue]
              dd Минимальное значение

              dt #[+ImportantEntity__Code--YDID maximalValue]
              dd Минимальное значение

      dt #[+ImportantEntity__Code--YDID BooleanParameterSpecification]
      dd

        | Спецификация #[+Keyword--YDID булевской] #[+Term--YDID опции].

        dl.Article-DescriptionList

          dt #[+ImportantEntity__Code--YDID type]
          dd.
            Для выполнения корректной валидации (как статической с помощью #[+ImportantEntity--YDID TypeScript], так и
              динамической), для #[+Keyword--YDID булевской] #[+Term--YDID опции] должно быть указано значение
              #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes.boolean]
              #[+Keyphrase--YDID и ничего другого].


      dt #[+ImportantEntity__Code--YDID JSON5_ParameterSpecification]
      dd

        | Спецификация #[+Keyword--YDID объектной] #[+Term--YDID опции], сериализованной в формате
        |   #[+ImportantEntity--YDID JSON5].

        dl.Article-DescriptionList

          dt #[+ImportantEntity__Code--YDID type]
          dd.
            Для выполнения корректной валидации (как статической с помощью #[+ImportantEntity--YDID TypeScript], так и
              динамической), для #[+Keyword--YDID объектной] #[+Term--YDID опции] должно быть указано значение
              #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes.JSON5]
              #[+Keyphrase--YDID и ничего другого].

          dt #[+ImportantEntity__Code--YDID validValueSpecification]
          dd.
            Спецификация #[+Keyword--YDID объектного] #[+Term--YDID значения] в формате
              #[+ImportantEntity__Code--YDID RawObjectDataProcessor.PropertiesSpecification], согласно которому оно
              будет валидировано после преобразования из #[+Term--YDID строки] в #[+Term__Contrast--YDID объект].


    h6.Article-Heading6 argumentsVector — Вектор аргументов

    h5.Article-Heading5 Возвращаемое значение

    h5.Article-Heading5 Локализация
