extends ../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../SharedAssets/Markup/SharedAssets.russian.pug
  include ../../../SharedComponents/SharedComponents.russian.pug

  include _ConsoleCommandsParser-DemoCodeViewer.pug


block append Metadata

  -

    RegularWebPageTemplate__YDF.configure({
      metadata: {
        title: buildHTML_PageTitle("ConsoleCommandsParser"),
        description: MetaDescriptionTemplates.class({
          className: "ConsoleCommandsParser",
          whatIsClassFor:
              "предназначен для разбора (парсинга) векторов аргументов консольных команд с валидацией и преобразованием их " +
                "к объектным TypeScript-типам. " +
              "Возможно также сгенерировать справочный текст для всех поддерживаемых команд."
        })
      },
      stylesSheetsURIs: [
        "$CommonStyles",
        "$LayoutsStyles/TwoColumns/TwoColumnsLayout.css",
        "$PreMadesStyles",
        "@CustomizedExternalComponents"
      ]
    });

    RoutingEmulator.setCurrentRoute("nodeJS.utils.ConsoleCommandsParser");

    LanguageDropDownList__YDF_DK.setLinks({
      english: routing.english.nodeJS.$children.utils.$children.ConsoleCommandsParser.$URI,
      japanese: routing.japanese.nodeJS.$children.utils.$children.ConsoleCommandsParser.$URI
    });

    const {
      $sectioning: localizedSectioning,
      $heading: topHeading
    } = localizedRouting.nodeJS.$children.utils.$children.ConsoleCommandsParser;


block append HeadScripts

  if __IS_PRODUCTION_BUILDING_MODE__

    +GoogleAnalyticsScript


block append SpecificContent

  article

    //- ━━━ Класс `ConsoleCommandsParser ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    h1.Article-Heading1!= topHeading

    +CompactTableOfContents--YDF_DK(localizedSectioning, { mustApplyAnchorsInsteadOfURIs: true })

    p.Article-Paragraph.
      #[+Term--YDID Класс], предназначенный для разбора (#[+Term--YDID парсинга]) #[+Term--YDID векторов аргументов]
        #[+Term__Contrast--YDID консольных команд] с валидацией и преобразованием их к #[+Term--YDID объектным]
        #[+Term__Contrast--YDID TypeScript-типам].
      Возможно также сгенерировать справочный текст для всех поддерживаемых команд.


    //- ━━━ Демо ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.demo.$heading,
      HTML_ID: localizedSectioning.demo.$anchor
    }).Article-Heading2

    p.Article-Paragraph Нижеследующей пример пример будет полностью разобран.

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true,
      specification: true
    })


    //- ━━━ Минимальные теоретические знания ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.minimalTheory.$heading,
      HTML_ID: localizedSectioning.minimalTheory.$anchor
    }).Article-Heading2

    p.Article-Paragraph
      | В отношении анатомии #[+Term--YDID консольных команд] официальная терминология и стандарты
      |   #[+Keyword--YDID отсутствуют] — #[+Keyphrase--YDID имеются лишь более-менее устоявшиеся соглашения].
      | В сухом остатке, #[+ImportantEntity__Code--YDID process.argv] (сокращение от #[+Term--YDID «arguments vector»]
      |   — #[+Term--YDID «вектор аргументов»],
      |
      +Link--YDF({
        unendorsedExternalURI: "https://stackoverflow.com/q/3024197/4818123"
      }).Article-Link унаследованная от языка C++ концепция
      | ) — всего лишь #[+Term--YDID массив] #[+Term__Contrast--YDID строк], а что с этими #[+Term--YDID строками]
      |   делать — решает разработчик приложения и/или его заказчики.

    p.Article-Paragraph.
      По сути, разбор #[+Term--YDID консольных команд] — это #[+Keyphrase--YDID частный случай]
        #[+Term--YDID задачи анализа произвольных внешних структурированных данных],
        в котором такими данными будет #[+Term--YDID индексный массив] #[+Term__Contrast--YDID строк], а значит
        #[+Keyword--YDID последовательность] #[+Term--YDID элементов] играет #[+Keyword--YDID ключевое] значение.
      #[+ImportantEntity--YDID Node.js] #[+Keyword--YDID не]&nbsp;предоставляет #[+Keyword--YDID никакой] функциональности
        для разбора таких #[+Term--YDID массивов] и их валидации, а сделать это безопасно (насколько возможно) с точки
        зрения #[+Term--YDID TypeScript-типизации] может ещё и не&nbsp;каждая сторонняя библиотека для работы с
        #[+Term--YDID консольными командами].


    //- ─── Соглашения по терминологии ─────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.minimalTheory.$children.conventionalTerminology.$heading,
      HTML_ID: localizedSectioning.minimalTheory.$children.conventionalTerminology.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      В общем виде #[+Term--YDID консольная команда] представляет собой последовательность #[+Term--YDID строчных значений],
        разделённых пробелом:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash }).
        команда аргумент1 аргумент2 ... аргументN

    p.Article-Paragraph.
      На примере утилиты #[+SecondaryEntity--YDID Webpack], конкретная команда может иметь вид:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash }).
        webpack build --mode development

    dl.Article-DescriptionList

      dt Команда
      dd.
        По пути, это #[+Term--YDID имя приложения] — полное #[+Keyword--YDID или] сокращённое.
        Например, у консольного интерфейса фреймворка #[+SecondaryEntity--YDID Angular] это
          #[+SecondaryEntity__Code--YDID ng], но чаще #[+Term--YDID команды] либо совпадают с полным именем приложения,
          либо близки к нему, например #[+SecondaryEntity__Code--YDID webpack], #[+SecondaryEntity__Code--YDID gulp],
          #[+SecondaryEntity__Code--YDID lerna].

      dt Опция (option) / Ключ опции (option key)
      dd.
        Начинается с #[+Keyword--YDID двойного] #[+Term--YDID дефиса] (как #[+SecondaryEntity__Code--YDID --mode] в
          примере выше).

      dt Параметр
      dd.
        #[+Term--YDID Значение] #[+Term__Contrast--YDID опции].
        Например, #[+SecondaryEntity__Code--YDID development] является #[+Term--YDID параметром]
          #[+Term__Contrast--YDID опции] #[+SecondaryEntity__Code--YDID --mode].

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.warning, SVG_Icon: true }).
      Из-за несовершенства устоявшейся терминологии, если приведённый выше определения вырвать из контекста
        #[+Term--YDID консольных команд], то они не&nbsp;только потеряют смысл, но внесут огромную путаницу.

    ul.Article-UnorderedList

      li.
        Если #[+Term--YDID опция] #[+Keyword--YDID не]&nbsp;имеет #[+Term__Contrast--YDID параметра], то она
          рассматривается　как #[+Term--YDID опция] #[+Keyword--YDID булевского]　#[+Term__Contrast--YDID типа] со
          значением　#[+ImportantEntity__Code--YDID true].
        Соответственно, когда этой #[+Term--YDID опции] #[+Keyword--YDID не]&nbsp;указано, это
          #[+Keyword--YDID равносильно] значению　#[+ImportantEntity__Code--YDID false].

      li.
        #[+Term--YDID Опция] может иметь сокращение, состоящее из одного #[+Term--YDID дефиса] и одной буквы (например,
          #[+SecondaryEntity__Code--YDID -d]).
        Примечательно, но для приведённого выше в качестве примера #[+SecondaryEntity__Code--YDID webpack]-а сокращение
          #[+SecondaryEntity__Code--YDID -m] имеется, только одно #[+Keyword--YDID не]&nbsp;является сокращением по
          отношению к　#[+SecondaryEntity__Code--YDID --mode].
        Как видно, сокращения хотя и быстры для ввода, но требуют повседневного использования для запоминания.

      li.
        #[+Term--YDID Аргументы] могут иметь пробелы, но при этом они должны быть обёрнуты в кавычки.

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.warning, SVG_Icon: true }).
      Существует также синтаксис
        #[+ImportantEntity__Code--YDID --опция1=параметр1 --опция2=параметр2 ... --опцияN=параметрN].
      На данный момент такой синтаксис #[+Keyword--YDID не]&nbsp;поддерживается
        #[+ImportantEntity--YDID ConsoleCommandsParser], однако если эта поддержка окажется востребована,
        то вероятно её добавление в будущих версиях.

    p.Article-Paragraph.
      Чем же тогда является #[+SecondaryEntity__Code--YDID build] в примере выше?
      Хороший вопрос и он заслуживает отдельного подраздела.


    //- ─── Термин «командная фраза» («command phrase») ────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.minimalTheory.$children.conventionalTerminology.$children.commandPhrase.$heading,
      HTML_ID: localizedSectioning.minimalTheory.$children.conventionalTerminology.$children.commandPhrase.$anchor
    }).Article-Heading4

    p.Article-Paragraph.
      #[+DefinableTerm--YDID Командная фраза («command phrase»)] — #[+Keyword--YDID первый] #[+Term--YDID аргумент]
        #[+Term--YDID консольной команды], #[+Keyphrase--YDID не&nbsp;являющиеся #[+Term--YDID опцией]] и ссылающийся
        на конкретную функциональность консольного приложения.
      Например, в #[+SecondaryEntity__Code--YDID yda build --mode DEVELOPMENT] #[+Term--YDID командной фразой]
        является #[+SecondaryEntity__Code--YDID build], однако ввиду того, что она #[+Keyword--YDID не]&nbsp;обязана
        состоять из одного слова, она и называется «фразой».
      В случаях, когда #[+Term--YDID командная фраза] состоит из нескольких слов, помимо оборачивания её в кавычки
        можно использовать слитные способы записи нескольких слов, такие как #[+Term--YDID верблюжий регистр].

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice, SVG_Icon: true }).
      Если можно было бы отойти от более-мене устоявшейся терминологии, то логично «команду» назвать
        «приложением», а «командную фразу» — «командой», но главный разработчик #[+ImportantEntity--YDID YDEE] на сей раз
        решил дополнить более-менее устоявшую терминологию несмотря на её запутанность, а не&nbsp;вводить её заново.

    p.Article-Paragraph.
      #[+Term--YDID Командная фраза] может быть явной или неявной (#[+Term--YDID командной фразой по умолчанию]).
      Например, в #[+SecondaryEntity__Code--YDID webpack build --mode development] #[+Term--YDID командная фраза] может
        #[+SecondaryEntity__Code--YDID build] является #[+Term--YDID командной фразой по умолчанию], а потому может
        быть опущена (#[+SecondaryEntity__Code--YDID webpack --mode development]).

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice, SVG_Icon: true }).
      Данный термин введён главным разработчиком #[+ImportantEntity--YDID YDEE].
      Если он используется где-то ещё, значит он был введён независимо, а потому может иметь другой смысл.


    //- ─── Дискриминантное объединение в TypeScript ───────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.minimalTheory.$children.TypeScriptDiscriminatedUnions.$heading,
      HTML_ID: localizedSectioning.minimalTheory.$children.TypeScriptDiscriminatedUnions.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      Для использования #[+ImportantEntity--YDID ConsoleCommandsParser] необходимо понимать концепцию
        #[+DefinableTerm--YDID дискриминантного объединения] в языке #[+ImportantEntity--YDID TypeScript].
      Суть её в том, что некоторый #[+Term--YDID тип (данных)] может быть #[+Keyphrase--YDID одним из нескольких]
        #[+Keyword--YDID объектных] #[+Term--YDID типов] с #[+Keyword--YDID определённым] набором
        #[+Term--YDID свойств], одно из которых отвечает за #[+Keyword--YDID идентификацию] конкретного
        #[+Term--YDID подтипа].
      Таким образом, #[+Term--YDID дискриминантное объединения] — это #[+Keyword--YDID обобщение] для нескольких
        #[+Keyword--YDID конкретных] #[+Term--YDID объектных типов], подобно тому, как под «легковым автомобилем»
        может подразумеваться «седан», «хэтчбэк», «минивэн» и другие, при этом набор типов в классификации
        #[+Keyword--YDID должен] быть #[+Keyword__Contrast--YDID конечным], а в документации к автомобилю имеется графа
        «тип», благодаря которой можно #[+Keyword--YDID однозначно] сказать, к какому типу принадлежит конкретный
        автомобиль.

    p.Article-Paragraph.
      Рассмотрим это на примере, имеющему отношение #[+ImportantEntity--YDID ConsoleCommandsParser].
      Допустим, разрабатываемая консольная утилита имеет #[+Term__Contrast--YDID командные фразы]
        #[+SecondaryEntity__Code--YDID build], #[+SecondaryEntity__Code--YDID pack],
        #[+SecondaryEntity__Code--YDID deploy] и #[+SecondaryEntity__Code--YDID help].
      Какой именно функциональности приложения они соответствуют — #[+Keyword--YDID сейчас] неважно, однако если для
        пользователей консольного приложения желательны короткие идентификаторы, а для разработчиков — содержательные,
        то можно короткие поместить в #[+Keyword--YDID значение] #[+Term--YDID перечисления]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        enum CommandPhrases {
          projectBuilding = "build",
          packingOfBuild = "pack",
          projectDeploying = "deploy",
          referenceGenerating = "referenceGenerating"
        }

    p.Article-Paragraph.
      Создадим #[+Term--YDID объект] #[+Keyphrase--YDID для каждой] #[+Term--YDID командной фразы], который будет
        включать в себя #[+Term--YDID свойство] #[+SecondaryEntity__Code--YDID phrase] с одним из значений определённого
        выше #[+Term--YDID перечисления] #[+SecondaryEntity__Code--YDID CommandPhrases], а так же #[+Term--YDID опции],
        актуальные для соответствующих #[+Term--YDID командных фраз].
      Пускай все #[+Term--YDID командные фразы], #[+Keyword--YDID кроме] #[+Keyword__Contrast--YDID последней], будут
        иметь #[+Term__Contrast--YDID опции].

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        type ProjectBuildingConsoleCommand = {
          phrase: CommandPhrases.projectBuilding;
          requiredStringOption: string;
          optionalStringOption?: string;
        };

        type PackingOfBuildConsoleCommand = {
          phrase: CommandPhrases.packingOfBuild;
          enumerationLikeStringOption: "FOO" | "BAR" | "BAZ";
          numericOption?: number;
          limitedNumericOption?: number;
        };

        type ProjectDeployingConsoleCommand = {
          phrase: CommandPhrases.projectDeploying;
          booleanOption: boolean;
          JSON5_Option?: Readonly<{ foo: string; bar?: number; }>;
        };

        type ReferenceGeneratingConsoleCommand = {
          phrase: CommandPhrases.referenceGenerating;
        };

    p.Article-Paragraph.
      Какую именно #[+Term--YDID командную фразу] введёт пользователь — мы #[+Keyword--YDID заранее] знать
        #[+Keyword__Contrast--YDID не]&nbsp;можем, однако #[+Keyphrase--YDID при правильно описанных правилах валидации]
        (мы разберём, как это делать) это будет #[+Keyphrase--YDID одна из] приведённых выше #[+Term--YDID командных фраз]
        с соответствующим ей набором #[+Term--YDID опций]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        type SupportedCommandsAndParametersCombinations =
            ProjectBuildingConsoleCommand |
            PackingOfBuildConsoleCommand |
            ProjectDeployingConsoleCommand |
            ReferenceGeneratingConsoleCommand;

    p.Article-Paragraph
      | #[+Term--YDID Метод] #[+ImportantEntity__Code--YDID parse] #[+Term--YDID класса]
      |   #[+ImportantEntity__Code--YDID ConsoleCommandsParser] вернёт #[+Term--YDID объект] определённого выше
      |   #[+Term--YDID типа] #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations] с
      |   #[+Keyword--YDID двумя] #[+Keyword__Contrast--YDID дополнительными] #[+Term--YDID свойствами]:
      |   #[+ImportantEntity__Code--YDID NodeJS_InterpreterAbsolutePath] и
      |   #[+ImportantEntity__Code--YDID executableFileAbsolutePath] — это #[+Keyword--YDID первые]
      |   #[+ImportantEntity--YDID 2] #[+Term--YDID элемента] #[+Term__Contrast--YDID массива]
      |   #[+ImportantEntity__Code--YDID process.argv].
      | По сути, #[+Term--YDID TypeScript-обобщение] #[+ImportantEntity__Code--YDID ParsedCommand] в
      |
      +ImportantEntity__Code--YDID: :code_listing--yda
        ParsedCommand<SupportedCommandsAndParametersCombinations>
      |   сообщает #[+ImportantEntity--YDID TypeScript]-y, что к #[+Keyphrase--YDID одному из] #[+Term--YDID подтипов]
      |   #[+Term__Contrast--YDID объединения] #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations]
      |   будут добавлены эти два #[+Term--YDID свойства]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        const parsedConsoleCommand: ConsoleCommandsParser.
            ParsedCommand<SupportedCommandsAndParametersCombinations> =
            ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

    p.Article-Paragraph.
      Но как мы узнаем, какую именно #[+Term--YDID командную фразу] ввёл пользователь приложения?
      Поскольку у #[+Keyword--YDID всех] #[+Term--YDID подтипов] #[+Term__Contrast--YDID дискриминантного объединения]
        #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations] имеется играющее роль идентификатора
        свойство #[+SecondaryEntity__Code--YDID phrase] с #[+Keyword--YDID уникальными]
        #[+Keyphrase--YDID в пределах этого #[+Term--YDID объединения]] значением, то с помощью
        #[+Term--YDID условных конструкций] (в данном случае идеально подходит
        #[+ImportantEntity__Code--YDID switch/case]) мы можем определить конкретный #[+Term--YDID подтип]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda

        switch (parsedConsoleCommand.phrase) {

          case ApplicationConsoleLineInterface.CommandPhrases.projectBuilding: {
            console.log("Build project");
            console.log(parsedConsoleCommand.requiredStringOption);
            console.log(parsedConsoleCommand.optionalStringOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.packingOfBuild: {
            console.log("Pack build");
            console.log(parsedConsoleCommand.enumerationLikeStringOption);
            console.log(parsedConsoleCommand.numericOption);
            console.log(parsedConsoleCommand.limitedNumericOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.projectDeploying: {
            console.log("Deploy project")
            console.log(parsedConsoleCommand.phrase);
            console.log(parsedConsoleCommand.booleanOption);
            console.log(parsedConsoleCommand.JSON5_Option);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.referenceGenerating: {
            console.log(ConsoleCommandsParser.generateFullHelpReference(ApplicationConsoleLineInterface.specification));
          }

        }

    p.Article-Paragraph.
      В результате, внутри #[+Keyword--YDID каждого] #[+ImportantEntity__Code--YDID case]-блока мы можем обращаться к
        #[+Term--YDID свойствам] #[+SecondaryEntity__Code--YDID parsedConsoleCommand],
        #[+Keyphrase--YDID соответствующим текущей #[+Term--YDID командной фразе]],
        а если попытаться вызывать свойство, ссылающееся на #[+Term--YDID опцию] другой #[+Term--YDID командной фразы],
        #[+ImportantEntity--YDID TypeScript] это заметит в виде ошибки.
      Правда, в примере много #[+Keyword--YDID необязательных] #[+Term--YDID свойств], поэтому перед тем, как ими
        пользоваться, потребуется проверка на #[+ImportantEntity__Code--YDID undefined].


    //- ━━━ Пошаговое руководство по созданию консольного интерфейса ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.stepwiseGuide.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$anchor
    }).Article-Heading2

    //- ─── Шаг 1 — Определение начального набора командных фраз ───────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.initialCommandPhrasesSet.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.initialCommandPhrasesSet.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      Решите, какие #[+Term--YDID командные фразы] будут доступны в Вашем приложении.

    ul.Article-UnorderedList

      li.
        Возможно, у Вас будет только одна #[+Term--YDID командная фраза].
        Если Ваше приложение узкоспециализированное, то это вполне нормально.

      li.
        В будущем Вы сможете добавить другие #[+Term--YDID командные фразы], потому на этом этапе можете ограничиться
          теми, назначение которых Вы более-менее осмыслили.

    p.Article-Paragraph.
      Поместите #[+Keyword--YDID все] Ваши #[+Term--YDID командные фразы] в #[+Term__Contrast--YDID перечисление].
      #[+Term--YDID Ключи перечисления] #[+Keyword--YDID не]&nbsp; обязательно должны совпадать с теми последовательностями
        символов, которые пользователь будет вводить в консоль: пускай #[+Term--YDID ключи] лучше будут подлиннее,
        но понятными для программистов #[+Keyphrase--YDID без документации], а если Вы, как и разработчики большинства
        консольных приложений, хотите сделать вводимые #[+Term--YDID командные фразы] короткими, то поместите их в
        #[+Keyword--YDID значения] #[+Term--YDID элементов перечисления].
      К счастью, #[+ImportantEntity--YDID TypeScript] позволяет определять #[+Keyword--YDID строчные]
        #[+Term--YDID перечисления], что невозможно или ограниченно во многих других языках программирования.

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        export enum CommandPhrases {
          projectBuilding = "build",
          packingOfBuild = "pack",
          projectDeploying = "deploy",
          referenceGenerating = "help"
        }

    p.Article-Paragraph.
      Как видно, в данном примере в качестве #[+Term--YDID ключей перечисления] выбраны словосочетания
        #[+Keyword--YDID без]&nbsp;#[+Term--YDID глаголов] — вместо них используются
        #[+Term--YDID отглагольные существительные], потому если наименование начинается с #[+Term--YDID глагола],
        но при этом #[+Keyword--YDID не]&nbsp;принадлежит #[+Term--YDID функции] или #[+Term--YDID методу], то это
        создаёт путаницу.
      Но это это требования стилистические, с которыми Вы можете не&nbsp;согласиться и установить собственные.

    +AdmonitionBlock--YDF({
      title: "Заметка об английской грамматике",
      decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice,
      SVG_Icon: true
    })
      ul.Article-UnorderedList

        li.
          Слово «build» может быть как глаголом, там и существительным, однако за предлогом «of»
            #[+Keyword--YDID не]&nbsp;может идти одиночного глагола, поэтому в примере выше «build» -
            существительное со значением «сборка» («собранный проект»).

        li.
          «Building» может быть существительным, глаголом или причастием, однако в значение существительного
            оно может означать как процесс, так и объект.
          В примере выше, это слово использовано #[+Keyword--YDID только] в значении #[+Keyword__Contrast--YDID процесса],
            а для объекта использовано слово «build» как существительное.

    p.Article-Paragraph.
      Рекомендуется писать этот код в #[+Keyword--YDID отдельном] файле, например
        #[+SecondaryEntity--YDID ApplicationConsoleLineInterface.ts].
      Кроме того, для чёткого определения контекста рекомендуем обернуть всё содержимое этого файла в
        #[+Term--YDID пространство имён], например #[+SecondaryEntity__Code--YDID ApplicationConsoleLineInterface].
      Хотя некоторые разработчики выступают против использование #[+Term--YDID пространств имён] (в
        #[+ImportantEntity--YDID TypeScript]), такое негативное отношение к #[+Term--YDID пространствам имён] обычно
        связано с устаревшими способами разбиения кода на модули, а такое использование, как в нашем примере
        (контекстный контейнер для #[+Term--YDID типов] и #[+Term--YDID констант]) #[+Keyword--YDID не]&nbsp;несёт
        в себе никаких проблем.

    +DemoCodeViewer({ commandPhrasesEnumeration: true })


    //- ─── Шаг 2 — Определение опций для командных фраз ───────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.commandPhrasesOptions.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.commandPhrasesOptions.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      Определитесь, какие #[+Term--YDID опции] Вы будете поддерживать #[+Keyphrase--YDID для каждой]
        #[+Term--YDID командной фразы], а также их #[+Term--YDID тип], обязательность и значения по умолчанию
        (если таковые имеются) #[+Keyword--YDID каждой] #[+Term--YDID опции].

    ul.Article-UnorderedList

      li.
        Опять же, для того, чтобы быстрее получить обратную связь от своего кода, #[+Keyphrase--YDID на начальном этапе]
          можно ограничиться минимальным набором #[+Term--YDID опций], наиболее осмысленных во время проектирования.

      li.
        Некоторые #[+Term--YDID командные фразы] могут #[+Keyword--YDID не]&nbsp;иметь #[+Term--YDID опций] — это нормально,
          а если Вы в будущем почувствуете необходимость в #[+Term--YDID опциях], то всегда сможете их добавить.
        В нашем примере #[+Term--YDID опций] #[+Keyword--YDID не]&nbsp;будет у #[+Term--YDID командной фразы]
          #[+SecondaryEntity__Code--YDID referenceGenerating].

    p.Article-Paragraph.
      Теперь, #[+Keyphrase--YDID для каждой] #[+Term--YDID командной фразы] определите
        #[+Term__Contrast--YDID объектный тип] со следующими #[+Term--YDID свойствами]:

    dl.Article-DescriptionList

      dt phrase
      dd.
        #[+Keyword--YDID Должно] содержать #[+Term--YDID элемент перечисления] #[+Term__Contrast--YDID командных фраз]
          (#[+SecondaryEntity__Code--YDID CommandPhrases] в примере выше),
          #[+Keyphrase--YDID соответствующий той же #[+Term--YDID командной фразе]],
          что и #[+Term--YDID тип], который Вы определяете.
        Это #[+Term--YDID свойство] играет роль #[+Keyword--YDID идентификатора], с помощью которого предстоит
          определять, какую именно #[+Term--YDID командную фразу] ввёл пользователь приложения.
        В качестве #[+Term--YDID типа] данного свойства нужно указывать #[+Keyword--YDID не]&nbsp;само
          перечисление (#[+SecondaryEntity__Code--YDID CommandPhrases] в примере выше), а его
          #[+Keyword--YDID конкретный] #[+Term--YDID элемент]
          (например, #[+SecondaryEntity__Code--YDID CommandPhrases.projectBuilding]) — с точки зрения
          #[+Term--YDID дискриминантных объединений] в #[+ImportantEntity--YDID TypeScript] это
          #[+Keyword--YDID не]&nbsp;бессмысленно.

      dt Опции командны
      dd

        p.Article-Paragraph.
          #[+Keyword--YDID Все] #[+Term--YDID опции] для текущей #[+Term--YDID командной фразы].
          #[+Term__Contrast--YDID Ключи] #[+Keyword--YDID не]&nbsp;обязательно должны совпадать с теми, которые
            пользователь будет вводить в консоль, поэтому давайте им такие имена, чтобы их смысл был ясен программистам
            #[+Keyphrase--YDID без документации].
          #[+Term--YDID Тип] #[+Keyword--YDID каждого] из этих #[+Term--YDID свойств] #[+Keyword--YDID должен] быть
            #[+Keyphrase--YDID одним из] следующих поддерживаемых #[+Term--YDID типов]:

        ul.Article-UnorderedList
          li #[+ImportantEntity__Code--YDID string]
          li #[+ImportantEntity__Code--YDID number]
          li #[+ImportantEntity__Code--YDID boolean]
          li
            | #[+Term--YDID Объект] на основе
            |
            +Link--YDF({
              internalURI: localizedRouting.coreLibrary.$children.
                  functionality.$children.
                  types.$children.
                  ParsedJSON_AndRelated.$URI
            }).Article-Link ParsedJSON
            |
            | из #[+Keyword--YDID главного] #[+Term--YDID пакета] (#[+ImportantEntity--YDID @yamato-daiwa/es-extensions])

        p.Article-Paragraph.
          Если же #[+Term--YDID опция] #[+Keyword--YDID необязательная] и
            #[+Keyphrase--YDID при этом #[+Keyword--YDID не]&nbsp; планируется #[+Term--YDID значения по умолчанию]],
            то перед #[+Term--YDID двоеточием] — разделителем #[+Term--YDID ключа] и #[+Term--YDID типа]
            #[+Term__Contrast--YDID значения] — #[+Keyword--YDID необходимо] поставить #[+Term--YDID вопросительный знак].

    p.Article-Paragraph.
      Наконец, объявите #[+Term--YDID TypeScript-объединение], в котором перечислены #[+Keyword--YDID все] только что
        созданные #[+Term--YDID объектные типы] #[+Keyphrase--YDID для каждой] #[+Term__Contrast--YDID командной фразы]
        (в примере ниже это #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations]).

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true
    })

    ul.Article-UnorderedList

      li.
        Снова обращаем Ваше внимание на то, какие могут быть стилистические требования по именованию #[+Term--YDID типов]:
          имя #[+Keyword--YDID каждого] #[+Term--YDID типа], соответствующего конкретной #[+Term--YDID командной фразе],
          #[+Keyword--YDID не]&nbsp;содержит #[+Term--YDID глаголов] и шаблонно заканчивается на
          #[+SecondaryEntity--YDID ConsoleCommand].

      li.
        Использование #[+Term--YDID утилитарного типа] #[+ImportantEntity--YDID Readonly]
          #[+Keyword--YDID не]&nbsp;обязательно, но #[+Keyword--YDID рекомендуется], потому что тем самым мы явно
          выражаем, что #[+Term--YDID свойства] определённых нами #[+Term--YDID объектных типов]
          #[+Keyword--YDID не]&nbsp;подлежат изменениям #[+Keyphrase--YDID в процессе выполнения программы].


    //- ─── Шаг 3 — Определение спецификации консольного приложения ────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.consoleApplicationSpecification.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.consoleApplicationSpecification.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      На основе #[+Term--YDID спецификации консольного приложения] будет осуществляться #[+Term--YDID разбор]
        (#[+Term--YDID парсинг]) и #[+Term__Contrast--YDID валидация] введённой #[+Term--YDID консольной команды],
        а при необходимости — генерация справки по использованию этого консольного приложения.

    p.Article-Paragraph.
      Определите #[+Term--YDID константу] #[+Term--YDID типа]
        #[+ImportantEntity__Code--YDID ConsoleCommandsParser.CommandLineInterfaceSpecification] —
        это #[+Keyword--YDID многоуровневый] #[+Term--YDID объект], в котором должна содержатся спецификация
        #[+Keyword--YDID всех] #[+Term--YDID командных фраз] включая #[+Term__Contrast--YDID опции] каждой из них,
        а также данные для генерации справки.
      Если Вы последовали совету обернуть код в #[+Term--YDID пространство имён] такое как
        #[+SecondaryEntity__Code--YDID ApplicationConsoleLineInterface],
        то длинного имени #[+Term--YDID константе] наподобие
        #[+SecondaryEntity__Code--YDID consoleCommandLineInterfaceSpecification]
        #[+Keyword--YDID не]&nbsp;требуется: у нас объявлен #[+Keyword--YDID контекст]
        #[+ImportantEntity--YDID ApplicationConsoleLineInterface], поэтому #[+Term--YDID константу] можно назвать просто
        #[+ImportantEntity__Code--YDID specification].

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true,
      specification: true
    })

    ol.Article-OrderedList

      li.
        #[+Term--YDID Свойству] #[+ImportantEntity__Code--YDID applicationName] укажите имя Вашего приложения.
        Оно #[+Keyword--YDID не]&nbsp;обязано совпадать с вводимым в консоль именем приложения, а если оно состоит
          из нескольких слов, то #[+Keyword--YDID можно] ввести их с разделением пробелом.
        Это значение будет использовано при генерации справки.

      li.
        В отличие от #[+ImportantEntity__Code--YDID applicationName], #[+Term--YDID свойство]
          #[+ImportantEntity__Code--YDID applicationDescription] — описание приложения — #[+Keyword--YDID необязательное],
          тем не&nbsp;менее заполнить его коротким описанием рекомендуется, чтобы сгенерированная справка была
          полноценной.

      li

        | #[+Term--YDID Свойство] #[+ImportantEntity__Code--YDID commandPhrases] должно содержать спецификации
        |   #[+Keyword--YDID каждой] #[+Term--YDID командной фразы].
        | Представляет собой #[+Term--YDID объект] #[+Term__Contrast--YDID типа] #[+Term--YDID «ассоциативный массив»],
        |   #[+Term--YDID ключи] которого #[+Keyword--YDID должны] совпадать с #[+Term--YDID командными фразами].
        | Надёжнее всего с использованием #[+Term--YDID скобочной записи] #[+Keyword--YDID сослать] #[+Term--YDID ключи]
        |   на нужный #[+Term--YDID элемент перечисления] #[+SecondaryEntity__Code--YDID CommandPhrases], например
        |   #[+SecondaryEntity__Code--YDID &lsqb;CommandPhrases.packingOfBuild&rsqb;].
        | Что касается #[+Term--YDID значений] этого #[+Term__Contrast--YDID ассоциативного массива], то:

        ul.Article-UnorderedList

          li.
            Если соответствующая #[+Term--YDID командная фраза] является
              #[+Term__Contrast--YDID командной фразой по умолчанию], то укажите
              #[+Term__Contrast--YDID булевскому свойству] #[+ImportantEntity__Code--YDID isDefault]
              значение #[+ImportantEntity__Code--YDID true].
            Поскольку #[+Term__Contrast--YDID командная фраза по умолчанию] может быть #[+Keyword--YDID только]
              #[+SecondaryEntity__Code--YDID одна], то #[+ImportantEntity__Code--YDID isDefault: true] должно быть
              указано #[+Keyword--YDID максимум] у #[+Keyword__Contrast--YDID одной] #[+Term--YDID командной фразы],
              #[+Keyphrase--YDID иначе выброшено исключение при запуске приложения].

          li.
            Подобно рассмотренному выше #[+ImportantEntity__Code--YDID applicationDescription], для спецификаций
              #[+Term--YDID командных фраз] предусмотрено #[+Term--YDID свойство]
              #[+ImportantEntity__Code--YDID description] — описание #[+Term--YDID командной фразы], которое хотя и
              #[+Keyword--YDID не]&nbsp;обязательно, но #[+Keyword__Contrast--YDID настоятельно]
              #[+Keyword--YDID рекомендуется] указать, чтобы сгенерировалась качественная справка.
            В примере выше описание пропущено лишь у #[+Term--YDID командной фразы] #[+SecondaryEntity__Code--YDID help]
              (#[+SecondaryEntity__Code--YDID CommandPhrases.referenceGenerating]).

          li.
            Если у #[+Term--YDID командной фразы] есть #[+Term--YDID опции], то их спецификацию необходимо указать
              в #[+Term--YDID свойстве] #[+ImportantEntity__Code--YDID options], которое также представляет собой
              #[+Term--YDID объект] типа #[+Term--YDID «ассоциативный массив»].

    //- ─── Определение опций командных фраз ───────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.
          stepwiseGuide.$children.consoleApplicationSpecification.$children.optionsSpecification.$heading,
      HTML_ID: localizedSectioning.
          stepwiseGuide.$children.consoleApplicationSpecification.$children.optionsSpecification.$anchor
    }).Article-Heading4

    p.Article-Paragraph.
      Большую часть времени этого этапа займёт именно определение #[+Term--YDID опций]
        #[+Term__Contrast--YDID комадных фраз], если таковых много.
      Сложного, однако, ничего нет: через #[+Term--YDID ключи] #[+Term__Contrast--YDID объекта]
        #[+Keyword--YDID необходимо] перечислить #[+Term--YDID опции]
        #[+Keyphrase--YDID такими, какими они будут введены в консоль], а через #[+Term--YDID значения]
        (#[+Keyword--YDID тоже] #[+Keyword__Contrast--YDID объектного] #[+Term--YDID типа]) —
        настройки этих #[+Term--YDID опций], такие как #[+Term--YDID тип], обязательность и так далее.
      Итак, #[+Keyphrase--YDID для каждой] #[+Term--YDID опции]:

    ol.Article-OrderedList

      li.
        Укажите #[+Term--YDID тип] #[+Term__Contrast--YDID опции] в виде #[+Term--YDID элемента перечисления]
          #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes].
        На данный момент поддерживаются #[+Keyword--YDID строчные], #[+Keyword--YDID числовые] и
          #[+Keyword--YDID булевские] #[+Term--YDID опции], а так же #[+Keyword--YDID объектные]
          (#[+Keyword--YDID должны] быть введены в консоль в формате #[+ImportantEntity--YDID JSON5]).

      li.
        Если #[+Term--YDID опция] имеет значение по умолчанию, то укажите значение #[+Keyword--YDID соответствующего]
          #[+Term--YDID типа] #[+Term__Contrast--YDID свойству] #[+ImportantEntity__Code--YDID defaultValue].
        #[+Keyphrase--YDID В противном случае], #[+Keyword--YDID необходимо] #[+Keyword__Contrast--YDID явно] указать
          #[+Keyword--YDID булевское] #[+Term--YDID свойство] #[+ImportantEntity__Code--YDID required]
          (естественно #[+ImportantEntity__Code--YDID true], если #[+Term--YDID опция] обязательна).
        При этом для #[+Keyword--YDID необязательной] #[+Keyword__Contrast--YDID булевской] #[+Term--YDID опции]
          указать #[+ImportantEntity__Code--YDID defaultValue] #[+Term--YDID TypeScript]
          #[+Keyword--YDID не]&nbsp;позволит, поскольку пропуск этого значения при вводе в консоль
          #[+Keyword--YDID равносилен] явно указанному значению #[+Keyword--YDID false].

      li.
        Если Вы пишете качественный код, а смысл короткого (в целях скорости ввода) имени #[+Term--YDID опции], которое
          будет введено в консоль, неясен без обращения к документации, то определите #[+Term--YDID свойство]
          #[+ImportantEntity__Code--YDID newName] более содержательным именем для программистов, которые будут
          поддерживать Ваш код.

      li.
        Если Вы хотите определить для #[+Term--YDID опции] #[+Keyword--YDID однобуквенное] сокращение, укажите
          соответствующее значение #[+Term--YDID свойству] #[+ImportantEntity__Code--YDID shortcut].
        Дефис, который пользователь должен будет указать при использовании этого сокращения, здесь, при определении,
          указывать #[+Keyword--YDID не]&nbsp;обязательно.

    p.Article-Paragraph.
      #[+Keyword--YDID Все] #[+Keyword__Contrast--YDID остальные] #[+Term--YDID свойства] зависят от #[+Term--YDID типа]
        #[+Term__Contrast--YDID опции].
      Рассмотрим их.


    //- ─── Специальные свойства строчных опций ────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 5,
      text: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfStringOptions.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfStringOptions.$anchor
    }).Article-Heading5

    p.Article-Paragraph.
      На данный момент такое #[+Term--YDID свойство] #[+Keyword--YDID только] #[+Keyword__Contrast--YDID одино] —
        #[+ImportantEntity__Code--YDID allowedAlternatives].
      Если Вы хотите, чтобы #[+Keyword--YDID строковая] #[+Term--YDID опция] могла принимать #[+Keyword--YDID только]
        значения из ограниченного набора вариантов, то укажите их в виде #[+Term--YDID массива]
        #[+Term__Contrast--YDID свойству] #[+ImportantEntity__Code--YDID allowedAlternatives].


    //- ─── Специальные свойства числовых опций ────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 5,
      text: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfNumericOptions.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfNumericOptions.$anchor
    }).Article-Heading5

    dl.Article-DescriptionList

      dt #[+ImportantEntity__Code--YDID numbersSet]
      dd

        | #[+Term--YDID Множество чисел], #[+Keyword--YDID обязательное] #[+Term--YDID свойство] для данного типа
        |   #[+Term--YDID опций].
        | Его значением #[+Keyword--YDID должен] быть #[+Keyphrase--YDID один из] #[+Term--YDID элементов перечисления],
        |   заимствованного из главного пакета библиотеки —
        |   #[+ImportantEntity__Code--YDID RawObjectDataProcessor.NumbersSets]:

        dl.Article-DescriptionList
          dt #[+ImportantEntity__Code--YDID naturalNumber]
          dd Натуральное число

          dt #[+ImportantEntity__Code--YDID nonNegativeInteger]
          dd Неотрицательное целое число

          dt #[+ImportantEntity__Code--YDID negativeInteger]
          dd Отрицательное целое число

          dt #[+ImportantEntity__Code--YDID negativeIntegerOrZero]
          dd Отрицательное целое число либо ноль

          dt #[+ImportantEntity__Code--YDID anyInteger]
          dd Любое целое число

          dt #[+ImportantEntity__Code--YDID positiveDecimalFraction]
          dd Положительная десятичная дробь

          dt #[+ImportantEntity__Code--YDID negativeDecimalFraction]
          dd Отрицательная десятичная дробь

          dt #[+ImportantEntity__Code--YDID decimalFractionOfAnySign]
          dd Любая десятичная дробь

          dt #[+ImportantEntity__Code--YDID anyRealNumber]
          dd Любое действительное число

      dt #[+ImportantEntity__Code--YDID minimalValue]
      dd Минимальное значение

      dt #[+ImportantEntity__Code--YDID maximalValue]
      dd Максимальное значение


    //- ─── Специальные свойства объектных опций ───────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 5,
      text: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfObjectOptions.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfObjectOptions.$anchor
    }).Article-Heading5

    p.Article-Paragraph.
      На данный момент такое #[+Term--YDID свойство] #[+Keyword--YDID только] #[+Keyword__Contrast--YDID одно], но
        #[+Keyword__Contrast--YDID обязательное] — #[+ImportantEntity__Code--YDID validValueSpecification].
      С помощью него необходимо задать правила валидации #[+Term--YDID объекта], в который будет преобразована
        #[+Term--YDID строка] формата #[+ImportantEntity--YDID JSON5].

    p.Article-Paragraph
      | Это #[+Term--YDID свойство] имеет #[+Term--YDID тип]
      |
      //- TODO Replace to internal link once ready
      +Link--YDF({
        endorsedExternalURI: "https://github.com/TokugawaTakeshi/Yamato-Daiwa-ES-Extensions/blob/master/CoreLibrary/Package/Documentation/RawObjectDataProcessor/RawObjectDataProcessor.md#propertiesspecification-and-related---object-properties-specification"
      }).Article-Link RawObjectDataProcessor.PropertiesSpecification
      |   , заимствованный из главного пакета библиотеки и очень похоже на спецификацию #[+Term--YDID опций]
      |   #[+Term--YDID командной фразы], только здесь используется #[+ImportantEntity__Code--YDID API]
      |   #[+Term--YDID класса] #[+ImportantEntity--YDID RawObjectDataProcessor].


    //- ─── Шаг 4 — Создание логики разбора консольных команд ──────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.logic.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.logic.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      На этом определение спецификации консольного приложения завершено; теперь её можно использовать при
        #[+Term--YDID разборе] (#[+Term--YDID парсинге]) введённой #[+Term--YDID консольной команды].
      Для этого #[+Keyword--YDID необходимо] у #[+Term--YDID класса] #[+ImportantEntity--YDID ConsoleCommandsParser]
        вызывать #[+Term--YDID статический метод] #[+ImportantEntity__Code--YDID parse]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        import { ConsoleCommandsParser } from "@yamato-daiwa/es-extensions-nodejs";
        import ApplicationConsoleLineInterface from "./ConsoleLineInterface";

        const parsedConsoleCommand: ConsoleCommandsParser.
            ParsedCommand<ApplicationConsoleLineInterface.SupportedCommandsAndParametersCombinations> =
            ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

    ul.Article-UnorderedList

      li.
        #[+Keyword--YDID Обязательным] #[+Term--YDID параметром] этого #[+Term--YDID метода] является спецификация
          консольного приложения, которую Вы определили на предыдущем шаге.

      li.
        Если #[+Keyword--YDID не]&nbsp;указывать #[+ImportantEntity--YDID 2го] #[+Term--YDID параметра], то
          #[+Term--YDID вектор аргументов] будет взят из #[+ImportantEntity__Code--YDID process.argv].

      li.
        В качестве #[+Term--YDID параметра обобщения] #[+Keyword--YDID необходимо] указать
          #[+Term--YDID TypeScript-объединение] #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations],
          которое Вы определили на #[+ImportantEntity--YDID 2-ом] шаге.

    p.Article-Paragraph.
      Теперь нам нужно определить, какая именно #[+Term--YDID командная фраза] была введена, а также безопасно
        (без #[+Term--YDID типа] #[+ImportantEntity__Code--YDID any] и ошибок #[+ImportantEntity--YDID TypeScript])
        обратиться к её #[+Term--YDID опциям] (разве что в случае #[+Keyword--YDID необязательными]
        #[+Term--YDID опциями] без значений по умолчанию потребуется проверка на
        #[+ImportantEntity__Code--YDID undefined], прежде чем ими полноценно пользоваться).
      Сделать это можно с помощью #[+ImportantEntity__Code--YDID switch/case]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        switch (parsedConsoleCommand.phrase) {

          case ApplicationConsoleLineInterface.CommandPhrases.projectBuilding: {
            console.log("Build project", parsedConsoleCommand);
            console.log("requiredStringOption", parsedConsoleCommand.requiredStringOption);
            console.log("optionalStringOption", parsedConsoleCommand.optionalStringOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.packingOfBuild: {
            console.log("Pack project", parsedConsoleCommand);
            console.log("enumerationLikeStringOption", parsedConsoleCommand.enumerationLikeStringOption);
            console.log("numericOption", parsedConsoleCommand.numericOption);
            console.log("limitedNumericOption", parsedConsoleCommand.limitedNumericOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.projectDeploying: {
            console.log("Deploy project", parsedConsoleCommand);
            console.log("booleanOption", parsedConsoleCommand.booleanOption);
            console.log("JSON5_Option", parsedConsoleCommand.JSON5_Option);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.referenceGenerating: {
            console.log(ConsoleCommandsParser.generateFullHelpReference(ApplicationConsoleLineInterface.specification));
          }

        }


    //- ─── Шаг 5 — Обеспечение запуска приложения по имени ────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.launchingOfApplicationByName.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.launchingOfApplicationByName.$anchor
    }).Article-Heading3

    p.Article-Paragraph
      | На данный момент приложение уже можно запускать #[+Keyphrase--YDID по пути файла] с помощью
      |
      +Link--YDF({ unendorsedExternalURI: sharedExternalLinks.tsNode.homePage.top }).Article-Link ts-node
      | , например:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        ts-node EntryPoint.test.ts --requiredStringOption test --optionalStringOption sample

    p.Article-Paragraph.
      Хотя такой вариант многих не&nbsp;устроит (потому что хотят запускать консольное приложение по
        #[+Term--YDID команде], то есть имени приложения — согласно запутанной, но устоявшейся терминологии), рассмотрим
        вкратце, когда он подходит и на завершённых предыдущих этапах можно остановиться.
      Прежде всего это случаи, когда разрабатываемый #[+Term--YDID консольный интерфейс] планируется применять
        #[+Keyword--YDID исключительно] в рамках #[+Keyword__Contrast--YDID одного] проекта
        #[+Keyword--YDID без]&nbsp;публикации в #[+ImportantEntity--YDID npm] или другими способами.
      В частности, это:

    dl.Article-DescriptionList

      dt Серверные приложения
      dd.
        Как правило, в таких приложениях одна #[+Term--YDID командная фраза] для запуска сервера, а через
          #[+Term--YDID опции] передаются #[+Term--YDID HTTP-порт], уровень логирования и так далее.

      dt Скрипты для автоматизации
      dd.
        Обычно это генерация, копирование или модификация файлов, причём задача насколько специфическая, что средства
          общего назначения, такие как #[+ImportantEntity--YDID Gulp], не&nbsp;подходят.

    p.Article-Paragraph.
      Хорошо, но как же всё-таки сделать возможным вызов утилиты по её #[+Term--YDID имени], подобно
        #[+SecondaryEntity--YDID gulp], #[+SecondaryEntity--YDID webpack] и так далее?

    p.Article-Paragraph.
      Во-первых, поскольку #[+Term--YDID рантайм] #[+ImportantEntity--YDID Node.js]
        #[+Keyword--YDID не]&nbsp;поддерживает #[+ImportantEntity--YDID TypeScript], то сначала
        #[+Keyword--YDID необходимо] обеспечить #[+Term--YDID транспайлинг] исходного кода в
        #[+ImportantEntity--YDID JavaScript].
      Сделать это можно как с помощью #[+Term--YDID консольного интерфейса] пакета #[+ImportantEntity--YDID TypeScript],
        так и с помощью специализированных утилит, таких как тот же самый #[+ImportantEntity--YDID Webpack] (
        потребуются один или более #[+Term--YDID плагинов] для работы с #[+ImportantEntity--YDID TypeScript]).

    p.Article-Paragraph.
      Однако перед тем, как запускать #[+Term--YDID транспайлинг], #[+Keyword--YDID необходимо] экспортировать из
        #[+Term--YDID точки входа] #[+Term__Contrast--YDID функцию] или же #[+Term--YDID класс], вызов одного из
        #[+Term--YDID методов] которого приведёт к выполнению логики приложения.
      «Экспортировать из точки входа» — звучит странно, ведь обычно в #[+Term--YDID точку входа] много что импортируется,
        но ничего не&nbsp;экспортируется.
      Объясняется это тем, что
        #[+Keyphrase--YDID в случае консольных #[+ImportantEntity--YDID Node.js]-утилит] #[+Term--YDID точка входа]
        выполняется #[+Keyword--YDID не]&nbsp;напрямую, а через через #[+Term--YDID исполняемый файл].
      Вот пример #[+Term--YDID точки входа], которая экспортирует #[+Term__Contrast--YDID функцию]
        #[+SecondaryEntity__Code--YDID executeApplication]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        import { ConsoleCommandsParser } from "@yamato-daiwa/es-extensions-nodejs";
        import ApplicationConsoleLineInterface from "./ConsoleLineInterface";


        export function executeApplication(): void {

          const parsedConsoleCommand: ConsoleCommandsParser.
              ParsedCommand<ApplicationConsoleLineInterface.SupportedCommandsAndParametersCombinations> =
              ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

          switch (parsedConsoleCommand.phrase) {

            case ApplicationConsoleLineInterface.CommandPhrases.projectBuilding: {
              // ...
              break;
            }

            case ApplicationConsoleLineInterface.CommandPhrases.packingOfBuild: {
              // ...
              break;
            }

            case ApplicationConsoleLineInterface.CommandPhrases.projectDeploying: {
              // ...
              break;
            }

            case ApplicationConsoleLineInterface.CommandPhrases.referenceGenerating: {
              console.log(ConsoleCommandsParser.generateFullHelpReference(ApplicationConsoleLineInterface.specification));
            }

          }

        }

    p.Article-Paragraph.
      Выполнив преобразование #[+Keyword--YDID исходного] кода в #[+ImportantEntity--YDID JavaScript], создайте ещё
        один #[+Keyword--YDID JavaScript]-файл (скажем, #[+SecondaryEntity--YDID Executable.js]) вручную с содержимым
        подобным следующему:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JavaScript
      }): :code_listing--yda
        #!/usr/bin/env node

        require("./EntryPoint").executeApplication();

    p.Article-Paragraph.
      Здесь первая строка содержит #[+Term--YDID шебанг], указывающий на то, что этот файл необходимо выполнять с помощью
        #[+ImportantEntity--YDID Node.js].
      Далее следует импортировать #[+Term--YDID функцию], запускающую приложение
        (#[+SecondaryEntity__Code--YDID executeApplication] в примере выше) и вызвать её.

    +QuestionAndAnswerBox--YDF({
      type: QuestionAndAnswerBox__YDF.Types.question,
      question: "Почему нельзя это файл сделать точкой входа? " +
          "Это же вроде как обычный JavaScript-файл, если не считать шебанга."
    }).
      В принципе можно, просто в таких #[+Term--YDID исполняемых файлах] не&nbsp;принято хранить логику, более сложную
        чем вызов одной #[+Term--YDID функции] или одного #[+Term--YDID метода].
      Однако это лишь рекомендация, а потому кто-то её соблюдает (например, разработчики #[+SecondaryEntity--YDID Gulp]),
        кто-то — нет (например, разработчики #[+SecondaryEntity--YDID Webpack], на моменты весны 2024 года).

    p.Article-Paragraph.
      Теперь, на этот #[+Term--YDID исполняемый файл] #[+Keyword--YDID необходимо] сослаться из файла
        #[+ImportantEntity--YDID package.json] Вашего проекта.
      Для того, чтобы утилита была доступна по #[+Term--YDID имени], #[+Keyword--YDID надо] заполнить #[+Term--YDID поле]
        #[+ImportantEntity__Code--YDID bin] #[+Term--YDID объектом] #[+Term__Contrast--YDID типа]
        #[+Term--YDID «ассоциативный массив»], #[+Keyword--YDID ключами] которого будут #[+Keyword--YDID команды], а
        #[+Keyword__Contrast--YDID значениями] — #[+Keyword--YDID относительные] #[+Term--YDID пути] к соответствующим
        #[+Term--YDID исполняемым файлам] (расширение #[+ImportantEntity--YDID «.js»] #[+Keyword--YDID можно] опустить):

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON
      }): :code_listing--yda
        {
          // ...
          "bin": {
            "my_app": "Executable"
          },
          // ...
        }

    p.Article-Paragraph
      | Более подробную информацию о #[+Term--YDID поле] #[+ImportantEntity__Code--YDID «bin»] Вы можете получить в
      |
      +Link--YDF({
        unendorsedExternalURI: sharedExternalLinks.npm.packageJSON.bin
      }).Article-Link официальной документации npm
      | .

    p.Article-Paragraph
      | Для того, чтобы устанавливать Вашу утилиту в другие проекты, нужно заполнить и другие #[+Term--YDID поля]
      |   #[+ImportantEntity--YDID package.json], такие как #[+ImportantEntity__Code--YDID name] и
      |   #[+ImportantEntity__Code--YDID version].
      | Ещё больше #[+Term--YDID полей] потребуется заполнить, если Вы собираетесь публиковать утилиту в
      |   #[+ImportantEntity--YDID npm].
      | На официальной сайте #[+ImportantEntity--YDID npm] есть
      |
      +Link--YDF({
        unendorsedExternalURI: sharedExternalLinks.npm.guides.minimalPackageJSON
      }).Article-Link краткое руководство по данной теме
      | .

    //-
      p.Article-Paragraph
        | Установить Ваш #[+Term--YDID npm-пакет] с консольной утилитой в другой проект можно разными способами:
        |   через #[+ImportantEntity__Code--YDID npm install &lsqb;package_name&rsqb;], если он опубликован,
        |
        +Link--YDF({
          unendorsedExternalURI: sharedExternalLinks.stackOverflow.installationOfLocalNPM_PackageByRelativePath
        }).Article-Link по относительному пути
        |   или
        |
        +Link--YDF({
          unendorsedExternalURI: sharedExternalLinks.stackOverflow.installationOfNPM_PackageByCommitNumber
        }).Article-Link по ссылке на коммит
        |   #[+Term--YDID системы контроля версий].
        | Как только Вы установите Вашу утилиту в другой проект тем или способом, то сможете вызывать её через
        |   #[+Term--YDID npm-скрипты], объявленные в #[+ImportantEntity--YDID package.json] этого проекта:

      +CodeViewer--YDF
        +CodeViewer-Listing--YDF({
          codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON
        }): :code_listing--yda
          {
            // ...
            "scripts": {
              "example": "my_app --option1 alpha --flag"
            },
            // ...
          }

      p.Article-Paragraph.
        Но опять же, это многих не устроит — ведь хотелось бы запускать утилиту напрямую из консоли по имени, как например:

      +CodeViewer--YDF
        +CodeViewer-Listing--YDF({
          codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash
        }): :code_listing--yda
          my_app --option1 alpha --flag
      //- TODO 和訳 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      p.Article-Paragraph.
        Если на этом этапе так и сделать, то Вы получите сообщение о том, что такой команды нет.
        В случае стандартного терминала #[+SecondaryEntity--YDID Windows] это будет:

      +ConsoleOutput--YDF.
        "my_app" не является внутренней иил внешней командой, исполняемой программной или пакетный файлом

      p.Article-Paragraph.
        Очень часто подобные сообщения вызывают удивление новичков, когда они пытаются воспользоваться
          #[+Term--YDID npm-пакетами] с консольным интерфейсом, такими как #[+SecondaryEntity--YDID gulp],
          #[+SecondaryEntity--YDID webpack], #[+SecondaryEntity--YDID ts-node] и так далее.
        Дело в том, что установка #[+Term--YDID npm-пакета] #[+Keyphrase--YDID в проект]
          #[+Keyword--YDID не]&nbsp;означает его установку на компьютер, а потому #[+Term--YDID операционная система]
          #[+Keyword--YDID не]&nbsp;знает, где искать введённую #[+Term--YDID команду].
      //- TODO 英訳 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      p.Article-Paragraph.
        Решить эту проблему можно по-разному.
        Наиболее популярными являются следующие решения.

      dl.Article-DescriptionList

        dt Глобальная установка
        dd.
          Если Вам действительно очень нужно, чтобы утилита запускалась #[+Keyword--YDID только] по своему имени,
            то можно её установить #[+Keyword--YDID глобально] (с флагом #[+SecondaryEntity__Code--YDID -g] при запуске
            #[+SecondaryEntity__Code--YDID npm install]).

        dt Использование #[+ImportantEntity--YDID npx]
        dd.
          Если Вы не хотите устанавливать утилиту глобально, но #[+ImportantEntity--YDID npm run] Вас тоже,
            не&nbsp;устраивает, то можно запустить утилиту через #[+SecondaryEntity__Code--YDID npx].
          При условии, что утилита (скажем, #[+SecondaryEntity__Code--YDID my_app]) установлена
            #[+SecondaryEntity__Code--YDID в проект], #[+ImportantEntity__Code--YDID npx myapp] запустит
            утилиту из проекта, в противном случае предложит её глобальную установку.
      //- TODO ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


      h2.Article-Heading2 Программный интерфейс класса ConsoleCommandsParser (API)

      p.Article-Paragraph.
        Все открытые методы и поля класса являются статическими, создание экземпляра класса без ошибок TypeScript
          невозможно.

      h3.Article-Heading3 Статические методы

      +CallableExpressionScheme--YDF_DK({
        technicalName: "parse",
        localizedDescriptiveHeading: "Проанализировать (консольную команду)",
        genericParameters: [
          {
            name: "TargetCommandsAndOptionsCombinations",
            extends: "ConsoleCommandsParser.GeneralizedCommandsAndOptionsCombinations"
          }
        ],
        parametersSpecification: [
          {
            genericTechnicalName: "commandLineInterfaceSpecification",
            localizedName: "Спецификация консольной команды",
            type: "ConsoleCommandsParser.CommandLineInterfaceSpecification",
            required: true
          },
          {
            genericTechnicalName: "argumentsVector",
            localizedName: "Вектор аргументов",
            type: "Array<string>",
            defaultValue: "process.argv"
          }
        ],
        returnedValue: "ConsoleCommandsParser.ParsedCommand<TargetCommandsAndOptionsCombinations>",
        headingTag: "h4"
      })

      p.Article-Paragraph.
        Анализирует #[+Term--YDID вектор аргументов] (по умолчанию #[+ImportantEntity__Code--YDID process.argv]) в
          соответствии со #[+Term--YDID спецификацией консольной команды], переданной через #[+Keyword--YDID первый]
          #[+Term--YDID параметр], и если #[+Term--YDID вектор аргументов] соответствует спецификации, то возвращает
          #[+Term--YDID объект], включающий в себя #[+Term--YDID опции консольной команды].

      +CodeViewer--YDF
        +CodeViewer-Listing--YDF({
          codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
        }): :code_listing--yda
          import { ConsoleCommandsParser } from "@yamato-daiwa/es-extensions-nodejs";
          import ApplicationConsoleLineInterface from "./ConsoleLineInterface";

          const parsedConsoleCommand: ConsoleCommandsParser.
              ParsedCommand<ApplicationConsoleLineInterface.SupportedCommandsAndParametersCombinations> =
              ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

      p.Article-Paragraph.
        Прежде, чем вызывать этот #[+Term--YDID метод], следует выполнить подготовительные работы, включающие в себя:

      ol.Article-OrderedList
        li.
          Проектирование #[+Term--YDID консольного интерфейса], заключающееся в принятии решений о том, какие
            будут в приложении #[+Term--YDID командные фразы] и соответствующие им #[+Term--YDID опции].
        li.
          Определение #[+Term--YDID дискриминантного объединения], #[+Keyword--YDID каждая] составляющая которого
            соответствует #[+Keyword--YDID конкретной] #[+Term--YDID командной фразе] и содержащей в себе
            #[+Term--YDID опции], #[+Keyphrase--YDID актуальные для этой #[+Term--YDID командной фразы]].
          Это #[+Term--YDID дискриминантное объединение] предстоит передать в качестве #[+Term--YDID параметра обобщения]
            #[+Term__Contrast--YDID метода] #[+ImportantEntity__Code--YDID parse].

        li.
          Определение #[+Term--YDID спецификации консольного приложения], в которой необходимо указать правила валидации
            #[+Term--YDID опций] для каждой #[+Term--YDID командной фразы], а также рекомендуется указать описания
            приложения в целом, #[+Term--YDID командных фраз] и #[+Term--YDID опций], чтобы можно было сгенерировать
            качественную справку.
          Эту #[+Term--YDID спецификации консольного приложения] предстоит передать в качестве #[+Keyword--YDID первого]
            #[+Term--YDID параметра] #[+Term--YDID метода] #[+ImportantEntity__Code--YDID parse].

      p.Article-Paragraph.
        Выше был разобран следующий пример выполнения этих подготовительных шагов:

      +DemoCodeViewer({
        commandPhrasesEnumeration: true,
        consoleCommandsObjectTypes: true,
        specification: true
      })


      h5.Article-Heading5 Параметр обобщения

      p.Article-Paragraph.
        Должен быть #[+Term--YDID дискриминантным объединением], #[+Keyword--YDID каждая] составляющая которого должна:

      ul.Article-UnorderedList

        li Соответствовать #[+Keyword--YDID конкретной] #[+Term--YDID командной фразе].

        li.
          Иметь #[+Term--YDID свойство], #[+Keyword--YDID однозначно] идентифицирующее #[+Term--YDID командную фразу],
            #[+Term__Contrast--YDID ключ] которого (например, #[+SecondaryEntity__Code--YDID phrase])
            #[+Keyphrase--YDID #[+Keyword--YDID общий] для всех составляющих], однако #[+Term--YDID значение]
            #[+Keyphrase--YDID в рамках #[+Term--YDID дискриминантного объединения]] #[+Keyword--YDID должно] быть
            #[+Keyword__Contrast--YDID уникальным].
          Чтобы гарантировать эту уникальность, можно, как показано в примере ниже, заготовить #[+Term--YDID перечисление]
            для всех #[+Term--YDID командных фраз] и указывать его #[+Term--YDID элемент] в качестве значения
            идентифицирующего свойства.

        li.
          Иметь #[+Term--YDID свойства], соответствующие той же #[+Term__Contrast--YDID командной фразе],
            что и идентифицирующее свойство.
          Если #[+Term--YDID опция] необязательная,
            #[+Keyphrase--YDID при этом #[+Keyword--YDID не]&nbsp;имеет значения по умолчанию],
            то #[+Keyword--YDID соответствующее] #[+Term--YDID TypeScript-свойство] #[+Keyword__Contrast--YDID необходимо]
            пометить символом #[+ImportantEntity__Code--YDID ?] после имени свойства.

      +DemoCodeViewer({
        commandPhrasesEnumeration: true,
        consoleCommandsObjectTypes: true
      })


      h5.Article-Heading5 Параметры

      h6.Article-Heading6 specification — Спецификация консольного приложения

      +ObjectTypeAbstract--YDF_DK({
        typeName: "ConsoleCommandsParser.CommandLineInterfaceSpecification",
        localizedDescriptiveHeading: "Спецификация консольной команды",
        propertiesSpecification: {
          applicationName: {
            localizedInterpretation: "Имя приложения",
            type: "string",
            required: true
          },
          applicationDescription: {
            localizedInterpretation: "Описание приложения",
            type: "string",
            required: false
          },
          commandPhrases: {
            localizedInterpretation: "Спецификация командных фраз",
            type: "{ [commandPhrase: string]: ConsoleCommandsParser.CommandPhraseSpecification; }",
            required: true
          }
        }
      })

      p.Article-Paragraph.
        #[+Keyword--YDID Многоуровневый] #[+Term--YDID объект], включающий в себя информацию о
          #[+Term--YDID консольном приложении] в целом, спецификацию #[+Term--YDID командных фраз] и
          #[+Term--YDID опций] для каждой из них.
        Используется для анализа #[+Term--YDID вектора аргументов], их валидации, а так же генерирования справки по
          использованию #[+Term--YDID консольного приложения].

      p.Article-Paragraph.
        #[+Keyword--YDID Верхний] уровень включает в себя #[+ImportantEntity--YDID 3] #[+Term--YDID свойства]:

      dl.Article-DescriptionList

        dt #[+ImportantEntity__Code--YDID applicationName]
        dd.
          Имя приложения.
          Используется при бросании #[+Term--YDID исключений], потому является обязательным.

        dt #[+ImportantEntity__Code--YDID applicationDescription]
        dd.
          Описание приложения.
          Используется исключительно для генерации справки.
          Хотя справка может быть сгенерирована и без этого #[+Term--YDID свойства], для повышения качества справки
            рекомендуется в одно-два предложения объяснить, для чего предназначено приложение.

        dt #[+ImportantEntity__Code--YDID commandPhrases]
        dd.
          Спецификация #[+Term--YDID командных фраз].
          #[+Term--YDID Объект] типа #[+Term__Contrast--YDID «ассоциативный массив»], #[+Keyword--YDID ключами] которого
            являются #[+Term--YDID командные фразы] #[+Keyphrase--YDID в таком виде, в каком их вводят в консоль].
          #[+Term--YDID Значениями] же являются #[+Term--YDID объекты] нижеследующего #[+Term--YDID типа].

      +ObjectTypeAbstract--YDF_DK({
        typeName: "ConsoleCommandsParser.CommandPhraseSpecification",
        localizedDescriptiveHeading: "Спецификация командной фразы",
        propertiesSpecification: {
          isDefault: {
            localizedInterpretation: "Является ли командной фразой по умолчанию",
            type: "boolean",
            required: false
          },
          description: {
            localizedInterpretation: "Описание (командной фразы)",
            type: "string",
            required: false
          },
          options: {
            localizedInterpretation: "Спецификация опцией командной фразы",
            type: "{ [optionKey: string]: ConsoleCommandsParser.OptionSpecification; }",
            required: false
          }
        }
      })

      dl.Article-DescriptionList

        dt #[+ImportantEntity__Code--YDID isDefault]
        dd.
          Является ли #[+Term--YDID командной фразой] #[+Keyphrase--YDID по умолчанию].
          Поскольку двух и более #[+Term--YDID командных фраз] по умолчанию быть #[+Keyword--YDID не]&nbsp;может,
            то если #[+ImportantEntity__Code--YDID { isDefault: true }]&nbsp;указано для двух и более
            #[+Term--YDID командных фраз], то #[+Keyphrase--YDID будет выброшено #[+Term--YDID исключение]].

        dt #[+ImportantEntity__Code--YDID description]
        dd.
          Описание #[+Term--YDID командной фразы].
          Используется исключительно для генерации справки.
          Хотя справка может быть сгенерирована и без этого #[+Term--YDID свойства], для повышения качества справки
            рекомендуется в одно-два предложения объяснить, какой функциональности соответствует
            #[+Term--YDID командная фразы].

        dt #[+ImportantEntity__Code--YDID options]
        dd.
          Спецификация #[+Term--YDID опций] #[+Term__Contrast--YDID командной фразы].
          #[+Term--YDID Объект] типа #[+Term__Contrast--YDID «ассоциативный массив»], #[+Keyword--YDID ключами] которого
            являются #[+Term--YDID ключи опций] #[+Keyphrase--YDID в таком виде, в каком их вводят в консоль].
          #[+Term--YDID Значениями] же являются #[+Term--YDID объекты] #[+Keyword--YDID полиморфного] #[+Term--YDID типа]
            #[+ImportantEntity__Code--YDID ConsoleCommandsParser.OptionSpecification].

      p.Article-Paragraph.
        #[+Keyphrase--YDID Вне зависимости от типа #[+Term--YDID опции]],
          #[+ImportantEntity__Code--YDID ConsoleCommandsParser.OptionSpecification] имеет следующие #[+Term--YDID свойства]:

      dl.Article-DescriptionList

        dt #[+ImportantEntity__Code--YDID description]
        dd.
          Описание #[+Term--YDID опции] #[+Term__Contrast--YDID командной фразы].
          Используется исключительно для генерации справки.
          Хотя справка может быть сгенерирована и без этого #[+Term--YDID свойства], для повышения качества справки
            рекомендуется в одно-два предложения объяснить, на что влияет данная #[+Term--YDID опция].

        dt #[+ImportantEntity__Code--YDID shortcut]
        dd.
          #[+Keyword--YDID Необязательное] #[+Keyword__Contrast--YDID однобуквенное] сокращение #[+Term--YDID ключа опции].
          Дефис указывать #[+Keyword--YDID не]&nbsp;обязательно.

        dt #[+ImportantEntity__Code--YDID newName]
        dd.
          Имя, под которым #[+Term--YDID опция] будет доступна по результатам разбора команды.
          Если в качестве ключей в #[+Term--YDID ассоциативном массиве]
            #[+ImportantEntity__Code--YDID options] #[+Keyword--YDID необходимо] указывать именно те строки,
            которые будут введены в консоль, то #[+Term--YDID свойство] #[+ImportantEntity__Code--YDID newName]
            этот ключ переименовать в более удобную для разработчиков последовательность символов.
          Если же переименование не&nbsp;требуется, то #[+ImportantEntity__Code--YDID newName] можно
            #[+Keyword--YDID не]&nbsp;указывать.

      p.Article-Paragraph.
        Остальные #[+Term--YDID свойства] зависят от конкретного типа #[+Term--YDID опции], который указывается через
          #[+Term--YDID свойство] #[+ImportantEntity__Code--YDID type].
        По сути, #[+ImportantEntity__Code--YDID ConsoleCommandsParser.OptionSpecification] является
          #[+Term--YDID дискриминантным объединением], где #[+ImportantEntity__Code--YDID type] —
          #[+Term--YDID идентифицирующее свойство], значением которого должен быть один из
          #[+Term--YDID элементов перечисления] #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes].

      +CodeViewer--YDF
        +CodeViewer-Listing--YDF({
          codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
        }): :code_listing--yda
          export type OptionSpecification =
              Readonly<{
                description?: string;
                shortcut?: string;
              }> &
              (
                StringOptionSpecification |
                NumberOptionSpecification |
                BooleanParameterSpecification |
                JSON5_ParameterSpecification
              );

      dl.Article-DescriptionList

        dt #[+ImportantEntity__Code--YDID StringOptionSpecification]
        dd

          | Спецификация #[+Keyword--YDID строчной] #[+Term--YDID опции].

          dl.Article-DescriptionList

            dt #[+ImportantEntity__Code--YDID type]
            dd.
              Для выполнения корректной валидации (как статической с помощью #[+ImportantEntity--YDID TypeScript], так и
                динамической), для #[+Keyword--YDID строчной] #[+Term--YDID опции] должно быть указано значение
                #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes.string]
                #[+Keyphrase--YDID и ничего другого].

            dt #[+ImportantEntity__Code--YDID allowedAlternatives]
            dd #[+Keyword--YDID Массив] допустимых значений.


        dt #[+ImportantEntity__Code--YDID NumberOptionSpecification]
        dd

          | Спецификация #[+Keyword--YDID числовой] #[+Term--YDID опции].

          dl.Article-DescriptionList

            dt #[+ImportantEntity__Code--YDID type]
            dd.
              Для выполнения корректной валидации (как статической с помощью #[+ImportantEntity--YDID TypeScript], так и
                динамической), для #[+Keyword--YDID числовой] #[+Term--YDID опции] должно быть указано значение
                #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes.number]
                #[+Keyphrase--YDID и ничего другого].


            dt #[+ImportantEntity__Code--YDID numbersSet]
            dd

              | #[+Term--YDID Множество чисел], которому должно удовлетворять введённое значение.
              | #[+Keyword--YDID Обязательно] для указания, поскольку от этого зависит алгоритм преобразования
              |   #[+Keyword--YDID строчного] значения (а #[+Term--YDID вектор аргументов] — это #[+Term--YDID массив]
              |   #[+Keyword--YDID строк]) в #[+Term--YDID число].
              | Должно быть #[+Term--YDID элементом перечисления]
              |   #[+ImportantEntity__Code--YDID RawObjectDataProcessor.NumbersSets], заимствованного из
              |   #[+Term--YDID класса] #[+ImportantEntity__Code--YDID RawObjectDataProcessor] основного пакета:

              dl.Article-DescriptionList

                dt #[+ImportantEntity__Code--YDID naturalNumber]
                dd Натуральное число

                dt #[+ImportantEntity__Code--YDID nonNegativeInteger]
                dd Неотрицательное целое число

                dt #[+ImportantEntity__Code--YDID negativeInteger]
                dd Отрицательное целое число

                dt #[+ImportantEntity__Code--YDID negativeIntegerOrZero]
                dd Отрицательное целое число либо ноль

                dt #[+ImportantEntity__Code--YDID anyInteger]
                dd Любое целое число

                dt #[+ImportantEntity__Code--YDID positiveDecimalFraction]
                dd Положительная десятичная дробь

                dt #[+ImportantEntity__Code--YDID negativeDecimalFraction]
                dd Отрицательная десятичная дробь

                dt #[+ImportantEntity__Code--YDID decimalFractionOfAnySign]
                dd Любая десятичная дробь

                dt #[+ImportantEntity__Code--YDID anyRealNumber]
                dd Любое действительное число

                dt #[+ImportantEntity__Code--YDID minimalValue]
                dd Минимальное значение

                dt #[+ImportantEntity__Code--YDID maximalValue]
                dd Минимальное значение

        dt #[+ImportantEntity__Code--YDID BooleanParameterSpecification]
        dd

          | Спецификация #[+Keyword--YDID булевской] #[+Term--YDID опции].

          dl.Article-DescriptionList

            dt #[+ImportantEntity__Code--YDID type]
            dd.
              Для выполнения корректной валидации (как статической с помощью #[+ImportantEntity--YDID TypeScript], так и
                динамической), для #[+Keyword--YDID булевской] #[+Term--YDID опции] должно быть указано значение
                #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes.boolean]
                #[+Keyphrase--YDID и ничего другого].


        dt #[+ImportantEntity__Code--YDID JSON5_ParameterSpecification]
        dd

          | Спецификация #[+Keyword--YDID объектной] #[+Term--YDID опции], сериализованной в формате
          |   #[+ImportantEntity--YDID JSON5].

          dl.Article-DescriptionList

            dt #[+ImportantEntity__Code--YDID type]
            dd.
              Для выполнения корректной валидации (как статической с помощью #[+ImportantEntity--YDID TypeScript], так и
                динамической), для #[+Keyword--YDID объектной] #[+Term--YDID опции] должно быть указано значение
                #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes.JSON5]
                #[+Keyphrase--YDID и ничего другого].

            dt #[+ImportantEntity__Code--YDID validValueSpecification]
            dd.
              Спецификация #[+Keyword--YDID объектного] #[+Term--YDID значения] в формате
                #[+ImportantEntity__Code--YDID RawObjectDataProcessor.PropertiesSpecification], согласно которому оно
                будет валидировано после преобразования из #[+Term--YDID строки] в #[+Term__Contrast--YDID объект].


      h6.Article-Heading6 argumentsVector — Вектор аргументов

      h5.Article-Heading5 Возвращаемое значение

      h5.Article-Heading5 Локализация
