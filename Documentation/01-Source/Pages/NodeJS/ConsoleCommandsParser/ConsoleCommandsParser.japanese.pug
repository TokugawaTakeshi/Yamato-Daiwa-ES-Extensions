extends ../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../SharedAssets/Markup/SharedAssets.japanese.pug
  include ../../../SharedComponents/SharedComponents.japanese.pug

  include _ConsoleCommandsParser-DemoCodeViewer.pug


block append Metadata

  -

    RegularWebPageTemplate__YDF.configure({
      metadata: {
        title: buildHTML_PageTitle("ConsoleCommandsParser"),
        description: MetaDescriptionTemplates.class({
          className: "ConsoleCommandsParser",
          whatIsClassFor:
              "クラスはコンソールコマンドの引数ベクトルの処理、バリデーションそしてオブジェクト系の特定のTypeScript型への変換のに使われている。" +
              "尚、全コマンドに関する参考本文（ヘルプ）生成機能もある。"
        })
      },
      stylesSheetsURIs: [
        "$CommonStyles",
        "$LayoutsStyles/TwoColumns/TwoColumnsLayout.css",
        "$PreMadesStyles",
        "@CustomizedExternalComponents"
      ]
    });

    RoutingEmulator.setCurrentRoute("nodeJS.utils.ConsoleCommandsParser");

    LanguageDropDownList__YDF_DK.setLinks({
      english: routing.english.nodeJS.$children.utils.$children.ConsoleCommandsParser.$URI,
      russian: routing.russian.nodeJS.$children.utils.$children.ConsoleCommandsParser.$URI
    });

    const {
      $sectioning: localizedSectioning,
      $heading: topHeading
    } = localizedRouting.nodeJS.$children.utils.$children.ConsoleCommandsParser;


block append HeadScripts

  if __IS_PRODUCTION_BUILDING_MODE__

    +GoogleAnalyticsScript


block append SpecificContent

  article

    //- ━━━ ConsoleCommandsParser`クラス` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    h1.Article-Heading1!= topHeading

    +CompactTableOfContents--YDF_DK(localizedSectioning, { mustApplyAnchorsInsteadOfURIs: true })

    p.Article-Paragraph.
      #[+Term--YDID コンソールコマンド]の#[+Term__Contrast--YDID 引数ベクトル]の処理、バリデーションそして#[+Term--YDID オブジェクト系]の特定の
        #[+Term--YDID TypeScript型]への変換のに使われている#[+Term--YDID クラス]である。
      尚、全コマンドに関する参考本文（ヘルプ）生成機能もある。


    //- ━━━ デモ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.demo.$heading,
      HTML_ID: localizedSectioning.demo.$anchor
    }).Article-Heading2

    p.Article-Paragraph.
      下記の例の詳しい解説が論述される。

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true,
      specification: true
    })


    //- ━━━ 最低限の理論 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.minimalTheory.$heading,
      HTML_ID: localizedSectioning.minimalTheory.$anchor
    }).Article-Heading2

    p.Article-Paragraph
      | #[+Term--YDID コンソールコマンド]に関する正式的な用語や此れの解剖学に対する規格は#[+Keyword--YDID 無く]、
      |   #[+Keyphrase--YDID 大体慣用のコンベンションしか存在してない]。
      | 事実上、#[+ImportantEntity--YDID Node.js]の#[+ImportantEntity__Code--YDID process.argv]（#[+Term--YDID 「引数ベクトル」]、
      +Link--YDF({
        unendorsedExternalURI: "https://stackoverflow.com/q/3024197/4818123"
      }).Article-Link C++言語から継承された概念
      | ）は#[+Term--YDID 文字列]の#[+Term__Contrast--YDID 配列]に過ぎない。
      | 此れをどうすれば良いか、開発者か其の依頼側か（其の両方か）が決めている。

    p.Article-Paragraph.
      実は、#[+Term--YDID コンソールコマンド]の解析は#[+Term--YDID 任意外部構成化データの解析の問題]の#[+Keyword--YDID 一種類]で、
        此処で此の外部のデータは#[+Term--YDID 文字列]の#[+Term__Contrast--YDID 指数配列]、従って#[+Term--YDID 要素]の
        #[+Keyword--YDID 順番]を考慮する必要が#[+Keyword--YDID 有る]。
      標準の#[+ImportantEntity--YDID Node.js]機能の中に、此の様な#[+Term--YDID 配列]の解析・妥当性確認専用の機能が
        #[+Keyword--YDID 無く]、#[+ImportantEntity--YDID TypeScript]の#[+Term--YDID 型付け]上可能な限り安全に解決出来る
        第三者のライブラリでも、存在しているとは限らない。


    //- ─── 条約的な用語 ─────────────────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.minimalTheory.$children.conventionalTerminology.$heading,
      HTML_ID: localizedSectioning.minimalTheory.$children.conventionalTerminology.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      全体的に、#[+Term--YDID コンソールコマンド]は空白に別けられている#[+Term--YDID 文字列]の値の順番に成っています。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash }).
        コマンド アーギュメント１ アーギュメント２ … アーギュメントN

    p.Article-Paragraph.
      例えば#[+SecondaryEntity--YDID Webpack]の場合、コマンドは下記の様に成る事がある。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash }).
        webpack build --mode development

    dl.Article-DescriptionList

      dt コマンド
      dd.
        事実上#[+Keyphrase--YDID アプリケーションの名前]に成っている（完全名か、省略名）。
        例えば、#[+SecondaryEntity--YDID Angular]フレームワークの場合、コマンドは#[+SecondaryEntity__Code--YDID ng]と言う省略である。
        然し普通はアプリケーションの名前と一致しているか、此れに近い（例：#[+SecondaryEntity__Code--YDID webpack]、
          #[+SecondaryEntity__Code--YDID gulp]、#[+SecondaryEntity__Code--YDID lerna]）。

      dt オプション（キー）
      dd.
        #[+Keyword--YDID ２重の]#[+Term--YDID nダッシュ]から始まる。
        上記の例に於いては#[+SecondaryEntity__Code--YDID --mode]。

      dt 引数
      dd.
        #[+Term--YDID オプション]の#[+Keyword--YDID 値]である。
        上記の例なら、#[+SecondaryEntity__Code--YDID development]は#[+SecondaryEntity__Code--YDID --mode]
          #[+Term--YDID オプションの引数]に成っている。

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.warning, SVG_Icon: true }).
      上記の慣用用語の非完全性のせい、此れを#[+Term--YDID コンソールコマンド]と言う文脈から切り離すと、意味を失うだけでなく大きい混乱を起こすのだ。

    ul.Article-UnorderedList

      li.

        #[+Term--YDID オプション]は#[+Term__Contrast--YDID 引数]が#[+Keyword--YDID 無い]場合、#[+Keyword--YDID 真]の値の
          #[+Keyword__Contrast--YDID ブーリアン]#[+Term--YDID オプション]として見做される。
        　此の様に、当#[+Term--YDID オプションが]指定されていない場合、#[+Keyword--YDID 偽]の値も同然。

      li.
        #[+Term--YDID オプション]が#[+Term__Contrast--YDID ハイフン]と一文字から成り立っている省略を持っている事が有る（例えば、
          「#[+SecondaryEntity__Code--YDID -d]」）。
        面白い事だが、上記の例に出た#[+SecondaryEntity--YDID Webpack]には、#[+SecondaryEntity__Code--YDID -m]と言う省略が存在してい
          はいるが、`--mode`の省略には#[+Keyword--YDID 成っていない]。
        御覧の様に、省略を入力する事が早い引き換え、暗記するには日常利用が必要。

      li.
        #[+Term--YDID アーギュメント]は空白を含める事は出来るが、此の場合括弧に包む事が必要に成る。

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.warning, SVG_Icon: true }).
      #[+ImportantEntity__Code--YDID --オプション1=引数1 --オプション2=引数2 ... --オプションN=引数N]と言った構文も存在している。
      現在#[+ImportantEntity--YDID ConsoleCommandsParser]に対応されていないが、需要が高いと言うフィードバックが届いたら、
        将来のバージョンに対応される可能性が有る。

    p.Article-Paragraph.
      上記の例に於いては#[+SecondaryEntity__Code--YDID build]とは何だろう？
      良い質問で、専用の節に相応しい。


    //- ─── 「コマンドフレーズ」用語 ────────────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.minimalTheory.$children.conventionalTerminology.$children.commandPhrase.$heading,
      HTML_ID: localizedSectioning.minimalTheory.$children.conventionalTerminology.$children.commandPhrase.$anchor
    }).Article-Heading4

    p.Article-Paragraph.
      #[+DefinableTerm--YDID コマンドフレーズ]（「#[+DefinableTerm--YDID command phrase]」）はコンソールアプリケーションの具体的な機能に該当
        している#[+Keyword--YDID 非オプション]である#[+Term--YDID コンソールコマンド]の#[+ImportantEntity--YDID １アーギュメント目]である。
      例えば、「#[+SecondaryEntity__Code--YDID yda build --mode DEVELOPMENT]」には「#[+SecondaryEntity__Code--YDID build]」は
        #[+Term--YDID コマンドフレーズ]ではあるが、一単語から成り立っているとは#[+Keyword--YDID 限らない]ので、「フレーズ」と呼ぶ。
      複数の単語から成り立っている時、此れを括弧に包むと他に、#[+Term--YDID キャメルケース]の様に無空白の書き方が活用出来る。

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice, SVG_Icon: true }).
      大体成り立っている用語から離れても良いとしたら、「コマンド」を「アプリケーション」、「コマンドフレーズ」を「コマンド」で呼んだら合理的だったはず。
      然し今回は#[+ImportantEntity--YDID YDEE]の主要な開発社は全く新しい用語を導入するのではなく、既存の用語を拡大する事にした。

    p.Article-Paragraph.
      #[+Term--YDID コマンドフレーズ]は明示的に成っている他に暗黙的に成っている事も有る（#[+Term--YDID 規定のコマンドフレーズ]）。
      例えば、#[+SecondaryEntity__Code--YDID webpack build --mode development]では#[+SecondaryEntity__Code--YDID build]は
        #[+Keyword--YDID 規定の]#[+Term--YDID コマンドフレーズ]なので、#[+SecondaryEntity__Code--YDID webpack --mode development]
        飛ばしても良いの様に飛ばしても良い。

    +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.notice, SVG_Icon: true }).
      此の用語は#[+ImportantEntity--YDID YDEE]の開発長に依り導入。
      此れが何処かで既に使われているとしたら、関係無いので、違う意味に成っている可能性が有る。


    //- ─── TypeScriptの差別化組合せ ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.minimalTheory.$children.TypeScriptDiscriminatedUnions.$heading,
      HTML_ID: localizedSectioning.minimalTheory.$children.TypeScriptDiscriminatedUnions.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      #[+ImportantEntity--YDID ConsoleCommandsParser]を用いるにはT#[+ImportantEntity--YDID ypeScript言語]の
        #[+Term--YDID 判別可能なユニオン型]の概念を理解する事が必要。
      一文で説明していると、#[+Term--YDID 判別可能なユニオン型]のものは、或る#[+Term--YDID オブジェクト型]は#[+Keyword--YDID 特定の]
        #[+Term--YDID プロパティ]の揃いから成り立っている#[+Keyword--YDID 複数の]#[+Term--YDID オブジェクト型]の中から何方かに
        成っているものであり、但し#[+Keyword--YDID 一つの]#[+Term--YDID プロパテ]ィは#[+Keyword--YDID 具体的な]#[+Term--YDID オブジェクト型]
        を#[+Keyword--YDID 識別]する。
      此の様に、#[+Term--YDID 判別可能なユニオン型]は#[+Keyword--YDID 複数の]#[+Keyword__Contrast--YDID 特定の]
        #[+Term--YDID オブジェクト型]の#[+Keyword--YDID 総括]。
      同じように、「普通車」は「セダン」、「ハッチバック」、「ワゴン車」等の総括で、但し種類の数が#[+Keyword--YDID 有限]で、車の種類が正しく判別するには車の資料に
        は「種類」と言う欄がある#[+Keyword--YDID 前提]。

    p.Article-Paragraph.
      #[+ImportantEntity--YDID ConsoleCommandsParser]と関連している例で此の概念を考察しよう。
      我らに開発されているコンソールアプリケーションは#[+SecondaryEntity__Code--YDID build]、#[+SecondaryEntity__Code--YDID pack]、
        #[+SecondaryEntity__Code--YDID deploy]、#[+SecondaryEntity__Code--YDID help]と言う#[+Term--YDID コマンドフレーズ]が有るとする。
      当の#[+Term--YDID コマンドフレーズ]はコンソールアプリケーションのどいった機能に該当しているか、後で考えれば良いが、ユーザー達にとって
        短い#[+Term--YDID コマンドフレーズ]の方が良い事に対して開発者達にとって一義的な#[+Term--YDID コマンドフレーズ]の方が良い時、短い奴を
        #[+Term--YDID 列挙]の#[+Keyword--YDID 値]の中に保持すれば良い。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        enum CommandPhrases {
          projectBuilding = "build",
          packingOfBuild = "pack",
          projectDeploying = "deploy",
          referenceGenerating = "referenceGenerating"
        }

    p.Article-Paragraph.
      #[+Keyword--YDID 各]#[+Term--YDID コマンドフレーズ]にとって以前定義された#[+Term--YDID 列挙]の#[+Keyword--YDID 一]
        #[+Term--YDID 要素]を含む#[+ImportantEntity__Code--YDID phrase]#[+Term--YDID プロパティ]と、該当している
        #[+Term--YDID コマンドフレーズ]の#[+Keyword--YDID 全]#[+Term--YDID オプション]から成り立っている#[+Term--YDID オブジェクト]を定義しておこう。
      最後の奴以外、全#[+Term--YDID コマンドフレーズ]は#[+Term__Contrast--YDID オプション]を持っているとする。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        type ProjectBuildingConsoleCommand = {
          phrase: CommandPhrases.projectBuilding;
          requiredStringOption: string;
          optionalStringOption?: string;
        };

        type PackingOfBuildConsoleCommand = {
          phrase: CommandPhrases.packingOfBuild;
          enumerationLikeStringOption: "FOO" | "BAR" | "BAZ";
          numericOption?: number;
          limitedNumericOption?: number;
        };

        type ProjectDeployingConsoleCommand = {
          phrase: CommandPhrases.projectDeploying;
          booleanOption: boolean;
          JSON5_Option?: Readonly<{ foo: string; bar?: number; }>;
        };

        type ReferenceGeneratingConsoleCommand = {
          phrase: CommandPhrases.referenceGenerating;
        };

    p.Article-Paragraph.
      利用者は何方の#[+Term--YDID コマンドフレーズ]を入力するか、我らは#[+Keyword--YDID 事前に]#[+Keyword__Contrast--YDID 知れないが]、
        #[+Keyphrase--YDID バリデーション規則を正しく定義すれば]（定後方法を後ほど説明する）以前定義された#[+Term--YDID コマンドフレーズ]の中一つ
        に成り、#[+Term--YDID オプション]も此の#[+Term__Contrast--YDID コマンドフレーズ]に該当していると#[+Keyword--YDID 保証]。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        type SupportedCommandsAndParametersCombinations =
            ProjectBuildingConsoleCommand |
            PackingOfBuildConsoleCommand |
            ProjectDeployingConsoleCommand |
            ReferenceGeneratingConsoleCommand;

    p.Article-Paragraph
      | #[+ImportantEntity__Code--YDID ConsoleCommandsParser]#[+Term--YDID クラス]の#[+ImportantEntity__Code--YDID parse]
      |   #[+Term--YDID メソッド]は#[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations]と
      |   #[+ImportantEntity__Code--YDID NodeJS_InterpreterAbsolutePath]と言う#[+Term--YDID プロパティ]
      |  （#[+ImportantEntity__Code--YDID process.argv]#[+Term--YDID 配列]の#[+Keyword--YDID 最初の]
      |   #[+ImportantEntity--YDID 2]#[+Term--YDID 要素]に該当している）付きの
      |   #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations]と言う以前定義された
      |   #[+Term--YDID 型]の#[+Term__Contrast--YDID オブジェクト]を返す。
      |   事実上、
      +ImportantEntity__Code--YDID: :code_listing--yda
        ParsedCommand<SupportedCommandsAndParametersCombinations>
      |   に於いて#[+ImportantEntity__Code--YDID ParsedCommand]#[+Term--YDID TypeScriptジェネリック]は、
      |   #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations]#[+Term--YDID ユニオン]
      |   に此の#[+ImportantEntity--YDID 2個]の#[+Term--YDID プロパティ]が追加されると#[+ImportantEntity--YDID TypeScript]
      |   に伝える。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        const parsedConsoleCommand: ConsoleCommandsParser.
            ParsedCommand<SupportedCommandsAndParametersCombinations> =
            ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

    p.Article-Paragraph.
      でも、利用者が具体的に何方の#[+Term--YDID コマンドフレーズ]を入力したか、どうやって判断すれば良いだろう。
      #[+Term--YDID 判別可能なユニオン]の#[+Keyword--YDID 全]#[+Term--YDID サブタイプ]は#[+SecondaryEntity__Code--YDID phrase]と
        言った#[+Keyphrase--YDID 当#[+Term--YDID ユニオン]の中に]#[+Keyword--YDID 唯一な]値の識別子役割の
        #[+Term--YDID プロパティ]を持っているので、条件構成（此の場合だと、#[+ImportantEntity__Code--YDID switch/case]が
        丁度良い）を持ちって具体的な#[+Term--YDID サブタイプ]が判断出来る。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda

        switch (parsedConsoleCommand.phrase) {

          case ApplicationConsoleLineInterface.CommandPhrases.projectBuilding: {
            console.log("Build project");
            console.log(parsedConsoleCommand.requiredStringOption);
            console.log(parsedConsoleCommand.optionalStringOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.packingOfBuild: {
            console.log("Pack build");
            console.log(parsedConsoleCommand.enumerationLikeStringOption);
            console.log(parsedConsoleCommand.numericOption);
            console.log(parsedConsoleCommand.limitedNumericOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.projectDeploying: {
            console.log("Deploy project")
            console.log(parsedConsoleCommand.phrase);
            console.log(parsedConsoleCommand.booleanOption);
            console.log(parsedConsoleCommand.JSON5_Option);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.referenceGenerating: {
            console.log(ConsoleCommandsParser.generateFullHelpReference(ApplicationConsoleLineInterface.specification));
          }

        }

    p.Article-Paragraph.
      結果のして、#[+Keyword--YDID 各]#[+Term--YDID caseブロック]の中に、現在の#[+Term--YDID コマンドフレーズ]に該当している
        #[+SecondaryEntity__Code--YDID parsedConsoleCommand]の#[+Term--YDID プロパティ]にアクセスする事が出来る。
      もし別の#[+Term--YDID コマンドフレーズ]に該当している#[+Term--YDID オプション]に参照している#[+Term--YDID プロパティ]にアクセスすると、
        #[+ImportantEntity--YDID TypeScript]が気付きエラーを起こす。
      但し、上記の例だと、#[+Keyword--YDID 任意な]#[+Term--YDID プロパティ]が多いので、これら使う前に
        #[+Term--YDID 非undefined確認]が必要に成る。


    //- ━━━ コマンドラインインターフェース（CLI）開発　｜　段階的な案内 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.stepwiseGuide.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$anchor
    }).Article-Heading2

    //- ─── ①　コマンドフレーズの初期揃いの決定 ─────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.initialCommandPhrasesSet.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.initialCommandPhrasesSet.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      貴方のアプリケーションの中に利用可能な#[+Term--YDID コマンドフレーズ]を決めておこう。

    ul.Article-UnorderedList

      li.
        単一の#[+Term--YDID コマンドフレーズ]が希望される場合が在る。
        アプリケーションの専門が幅狭ければ、通常の事だと考えられる。

      li.
        いつでも新しい#[+Term--YDID コマンドフレーズ]が追加出来るから、取り敢えず自分にとって明確な#[+Term--YDID コマンドフレーズ]を決めよう。

    p.Article-Paragraph.
      #[+Keyword--YDID 全]#[+Term--YDID コマンドフレーズ]を#[+Term__Contrast--YDID 列挙]の中に保持しておこう。
      #[+Term--YDID 列挙]の#[+Keyword--YDID キー]はコンソールに実際に入力される文字列と一致させる必要はなく、#[+Keyphrase--YDID 資料が無くても]
        #[+Term--YDID キー]の意味が開発者にとって明かにした方が良い。
      多数の開発者と同じ様に、実際に入力される文字列を短くしたいなら、これらを#[+Term--YDID 列挙要素]の#[+Keyword--YDID 値]に保持しておこう。
      幸いに#[+ImportantEntity--YDID TypeScript]なら#[+Term--YDID 文字列]#[+Term__Contrast--YDID 要素]の
        #[+Term--YDID 列挙]が定義可能で、他の言語なら、同じ機能が無いか制限が有る事が多い。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        export enum CommandPhrases {
          projectBuilding = "build",
          packingOfBuild = "pack",
          projectDeploying = "deploy",
          referenceGenerating = "help"
        }

    p.Article-Paragraph.
      上記通り、#[+Term--YDID 列挙]の#[+Term__Contrast--YDID キー]として#[+Term--YDID 動詞]#[+Keyword--YDID 無し]の単語の組み合わせ
        であり、代わりに#[+Term--YDID 動名詞]が使われている。
      名前は#[+Term--YDID 動詞]から始まるが、#[+Term--YDID 関数]・#[+Term--YDID メソッド]の名前に成っていないと、混乱が発生する。
      然し、スタイルガイド定期な要求と成っているので、反対し自分の規律が導入出来る。

    p.Article-Paragraph.
      此のコードべ#[+Keyword--YDID 別の]ファイル（例えば、#[+SecondaryEntity--YDID ApplicationConsoleLineInterface.ts]）で書く推薦。
      其れに、明確なコンテキストの定義の為当ファイルの中身を#[+Term--YDID 名スペース]
        （例えば#[+SecondaryEntity__Code--YDID ApplicationConsoleLineInterface]）に包む事を御勧め。
      開発者達の中に（#[+ImportantEntity--YDID TypeScript]の）#[+Term--YDID 名スペース]の反対派は居るが、こういった
        #[+Term--YDID 名スペース]の否定的な評判の原因は、コードをモジュールに分割する旧い方法に多く有る。
      上記の例の様に、#[+Term--YDID 名スペース]を#[+Term__Contrast--YDID 型]や#[+Term__Contrast--YDID 定数]の為のコンテキストコンテナー
        として使っても、悪影響が特に#[+Keyword--YDID 無い]。


    //- ─── ②　各コマンドフレーズのオプションの決定 ────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.commandPhrasesOptions.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.commandPhrasesOptions.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      #[+Keyword--YDID 各]#[+Term--YDID コマンドフレーズ]にとって#[+Term--YDID オプション]の揃い（#[+Term--YDID 型]、
        #[+Term--YDID 必須性]や有れば#[+Term--YDID 規定値]）を決めておこう。

    ul.Article-UnorderedList

      li.
        #[+Term--YDID コマンドフレーズ]の場合と同じ様に、より早く自分のコードからフィードバックを取るには#[+Keyphrase--YDID 初期段階では]自分にとって
          最も明確で、最低限の#[+Term--YDID オプション]にすれば良い。

      li.
        一部分の#[+Term--YDID コマンドフレーズ]が#[+Term__Contrast--YDID オプション]が無い事が有る。
        特に問題無い事であり、将来的に#[+Term--YDID オプション]が必要に成ったら、其の時追加されば良い。
        現在の例だと、#[+SecondaryEntity__Code--YDID referenceGenerating]#[+Term--YDID コマンドフレーズ]は
          #[+Term__Contrast--YDID オプション]が#[+Keyword--YDID 無い]。

    p.Article-Paragraph.
      今、#[+Keyword--YDID 各]#[+Term--YDID コマンドフレーズ]にとって下記の#[+Term--YDID プロパティ]を含む#[+Term--YDID オブジェクト型]
        を定義しておこう。

    dl.Article-DescriptionList

      dt phrase
      dd.
        #[+Term--YDID オブジェクト型]自体と同じ#[+Term--YDID コマンドフレーズ]に該当している#[+Term--YDID コマンドフレーズ]の
          #[+Term__Contrast--YDID 列挙]（上記の例に於いては#[+SecondaryEntity__Code--YDID CommandPhrases]）の
          #[+Term--YDID 要素]で#[+Keyword--YDID なくてはならない]。
        当プロパティは#[+Keyword--YDID 識別子]の様に成り、利用者は具体的に何方の#[+Term--YDID コマンドフレーズ]の入力したか、判別するのに使われる。
        此れの#[+Term--YDID 型]は、#[+Term--YDID 列挙]自体では#[+Keyword--YDID なく]
        （上記の例だと#[+SecondaryEntity__Code--YDID CommandPhrases]）、此の#[+Term--YDID 列挙]の具体的な#[+Term--YDID 要素]
        （例えば#[+SecondaryEntity__Code--YDID CommandPhrases.projectBuilding]）にしてはいけない
        （#[+ImportantEntity--YDID TypeScript]の#[+Term--YDID 差別化組合せ]上は意味の無い事では#[+Keyword--YDID ない]）。

      dt コマンドのオプション
      dd

        p.Article-Paragraph.
          対象の#[+Term--YDID コマンドフレーズ]のに該当している全#[+Term--YDID オプション]。
          #[+Term--YDID キー]は利用者によりコンソール入力されるものと必ず一致させなければいけない訳では#[+Keyword--YDID なく]、
            #[+Keyphrase--YDID 資料が無くても]和訳出来るエンジン達にとって意味を明確にすれば良い。
          #[+Keyword--YDID 各]#[+Term--YDID プロパティ]の#[+Term--YDID 型]は下記の利用可能な#[+Term--YDID 型]の何方か
            でなくてはならない。

        ul.Article-UnorderedList
          li #[+ImportantEntity__Code--YDID string]
          li #[+ImportantEntity__Code--YDID number]
          li #[+ImportantEntity__Code--YDID boolean]
          li
            | #[+Keyword--YDID 主要]#[+Term--YDID パッケージ]（#[+ImportantEntity--YDID @yamato-daiwa/es-extensions]）からの
            +Link--YDF({
              internalURI: localizedRouting.coreLibrary.$children.
                  functionality.$children.
                  types.$children.
                  ParsedJSON_AndRelated.$URI
            }).Article-Link ParsedJSON
            | 系の#[+Term--YDID オブジェクト]

        p.Article-Paragraph.
          #[+Term--YDID オプション]は#[+Keyword--YDID 任意]で、#[+Keyphrase--YDID 但し規定値は予定#[+Keyword--YDID されていない]]場合、
            #[+Term--YDID コロン]（#[+Term--YDID キー]と#[+Term__Contrast--YDID 値]の#[+Term--YDID 型]の区切り）の前に
            #[+Term--YDID 疑問符]を入れる#[+Keyphrase--YDID 必要が有る]。

    p.Article-Paragraph.
      やがて、#[+Keyword--YDID 各]#[+Term--YDID コマンドフレーズ]に該当している以前作った#[+Term--YDID オブジェクト型]にとって
        #[+Term--YDID ユニオン]を定義しておいてください （下記の例に於いては
        #[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations]）。

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true
    })

    ul.Article-UnorderedList

      li.
        再び名前の付け方と関連しているスタイルガイドの例に気を付けてもらいたい。
        具体的な#[+Term--YDID コマンドフレーズ]に該当している#[+Keyword--YDID 各]#[+Term--YDID 型]の名前は#[+Term--YDID 動詞]を
          #[+Keyword--YDID 含めていなく]、#[+SecondaryEntity--YDID ～ConsoleCommand]末尾は原型と成っています。

      li.
        #[+ImportantEntity--YDID Readonly]と言う#[+Term--YDID ユーティリティ型]の利用は必須では#[+Keyword--YDID ない]が、
          #[+Keyword--YDID 推薦]だ。
        此れを使う事に依り、以前宣言された#[+Term--YDID オブジェクト型]の#[+Term__Contrast--YDID プロパティ]はプログラミングの実行中変わる事は無い
          と明示的に指示する。


    //- ─── ③　コンソールアプリケーションの仕様を定義 ──────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.consoleApplicationSpecification.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.consoleApplicationSpecification.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      #[+Term--YDID コンソールアプリケーション仕様]通りに入力された#[+Term--YDID コンソールコマンド]がバリデーション・処理される事に成り、
        必要に応じて当コンソールアプリケーションの使い方に対して案内本文が生成される。

    p.Article-Paragraph.
      #[+ImportantEntity__Code--YDID ConsoleCommandsParser.CommandLineInterfaceSpecification]#[+Term--YDID 型]の
        #[+Term--YDID 定数]を定義しておこう。
      #[+Keyword--YDID 多層]#[+Term--YDID オブジェクト型]と成り、#[+Keyword--YDID 全]#[+Keyword--YDID コマンドフレーズ]
        （各一個の#[+Term--YDID オプション]を含めて）の定義及び案内を生成する為のデータを#[+Keyword--YDID 含まなければいけません]。
      #[+SecondaryEntity__Code--YDID ApplicationConsoleLineInterface]の様な#[+Term--YDID 名スペース]にコードを包む推薦通り
        してくれた場合、#[+SecondaryEntity__Code--YDID consoleCommandLineInterfaceSpecification]の様に長い#[+Term--YDID 定数名]
        は#[+Keyword--YDID 不要]で、#[+ImportantEntity--YDID ApplicationConsoleLineInterface]と言う#[+Keyword--YDID コンテキスト]
        が有るから、単に#[+ImportantEntity__Code--YDID specification]だけで良い。

    +DemoCodeViewer({
      commandPhrasesEnumeration: true,
      consoleCommandsObjectTypes: true,
      specification: true
    })

    ol.Article-OrderedList

      li.
        #[+ImportantEntity__Code--YDID applicationName]#[+Term--YDID プロパティ]に貴方のアプリケーションの名前を指定しておこう。
        ターミナルに入力される名前と必ずしも一致しなければいけない訳では#[+Keyword--YDID なく]、複数の言葉から成り立っている場合空白で訳ても良い。
        指定された名前は参考の生成の為に使われる。

      li.
        #[+ImportantEntity__Code--YDID applicationName]と違って、#[+ImportantEntity__Code--YDID applicationDescription]
          （和訳：アプリケーションの記述）#[+Term--YDID プロパティ]は#[+Keyword--YDID 任意]ではありますが、ちゃんとした参考を生成するには
          短くても良いからアプリケーションについて一言を指定する推薦。

      li

        | #[+ImportantEntity__Code--YDID commandPhrases]#[+Term--YDID プロパティ]は
        |   #[+Keyword--YDID 各]#[+Term--YDID コマンドフレーズ]の仕様を含めなくてはならない。
        | #[+Keyword--YDID 連想配列系の]#[+Term--YDID オブジェクト]と成り、#[+Term--YDID キー]は#[+Term--YDID コマンドフレーズ]と一致
        |   しなければいけない。
        | 一番安全なのは、#[+Term--YDID ブラケット表記法]を活用し、当#[+Term--YDID オブジェクト]の#[+Term__Contrast--YDID キー]を
        |   #[+SecondaryEntity__Code--YDID CommandPhrases]#[+Term--YDID 列挙]の#[+Term__Contrast--YDID 要素]に
        |   結び付く事（例えば、#[+SecondaryEntity__Code--YDID &lsqb;CommandPhrases.packingOfBuild&rsqb;]）。
        | #[+Term--YDID 連想配列]の#[+Term__Contrast--YDID 値]なら、

        ul.Article-UnorderedList

          li.
            該当している#[+Term--YDID コマンドフレーズ]は規定に成っている場合、#[+ImportantEntity__Code--YDID isDefault]と言う
              #[+Keyword--YDID 真偽型の]プロパティに#[+ImportantEntity__Code--YDID true]をしていする事。
            #[+Keyword--YDID 規定の]#[+Term--YDID コマンドフレーズ]は#[+ImportantEntity--YDID 一個]#[+Keyword--YDID しか]
              有り得ないので、#[+ImportantEntity__Code--YDID isDefault: true]を指定しても良いのは、#[+Keyword--YDID 最大]
              #[+ImportantEntity--YDID 一個]の#[+Term--YDID コマンドフレーズ]、
              #[+Keyphrase--YDID さもなくばアプリケーションの起動の際例外が投げられる]。

          li.
            上述の#[+ImportantEntity__Code--YDID applicationDescription]の様に、#[+Term--YDID コマンドフレーズ]の仕様には
              #[+ImportantEntity__Code--YDID description]#[+Term--YDID プロパティ]（和訳：#[+Term--YDID コマンドフレーズ]の記述）が指定
              出来る。
            #[+Keyword--YDID 任意]に成ってはいるが、高品質の参考本文を生成するにはしたいした方が良い。
            上記の例だと、#[+SecondaryEntity__Code--YDID help]
              (#[+SecondaryEntity__Code--YDID CommandPhrases.referenceGenerating])コマンドだけ記述がついていない。

          li.
            #[+Term--YDID コマンドフレーズ]が#[+Term__Contrast--YDID オプション]がある場合、#[+ImportantEntity__Code--YDID options]
              #[+Term--YDID プロパティ]（こいつも#[+Keyword--YDID 連想配列系]の#[+Term--YDID オブジェクト]である）を埋める事。


    //- ─── 各コマンドフレーズのオプションの定義 ───────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.
          stepwiseGuide.$children.consoleApplicationSpecification.$children.optionsSpecification.$heading,
      HTML_ID: localizedSectioning.
          stepwiseGuide.$children.consoleApplicationSpecification.$children.optionsSpecification.$anchor
    }).Article-Heading4

    p.Article-Paragraph.
      #[+Term--YDID コマンドフレーズ]の#[+Term__Contrast--YDID オプション]が多ければ、#[+Term--YDID コマンドフレーズ]の
        #[+Term__Contrast--YDID オプション]の使用定義こそ此の段階の大抵の時間がかかる。
      とは言え、難しい事は無くて、コンソールに入力される値と同じ#[+Keyphrase--YDID 対象#[+Term--YDID コマンドフレーズ]の]
        #[+Keyword--YDID 全]#[+Term--YDID オプション]を#[+Term--YDID オブジェクト]の#[+Keyword--YDID キー]で指定し、
        #[+Term--YDID オブジェクト]の#[+Keyword--YDID 値]なら、#[+Keyword--YDID オブジェクト型]と成り、下記通り此れの中に
        #[+Term--YDID オプション]の#[+Term__Contrast--YDID 型]、必須・任意等を指定すれば良い。

    ol.Article-OrderedList

      li.
        #[+ImportantEntity__Code--YDID ConsoleCommandsParser.ParametersTypes]#[+Term--YDID 列挙]の
          #[+Term__Contrast--YDID 要素]で#[+Term--YDID オプション]の#[+Term__Contrast--YDID 型]を指定しておこう。
        現在、#[+Term--YDID 文字列型]、#[+Term--YDID 数型]、#[+Term--YDID 真偽型]及び#[+Term--YDID オブジェクト型]
          （入力の際妥当な#[+ImportantEntity--YDID JSON5型]の#[+Term--YDID 文字列]#[+Keyword--YDID でなければけない]）。
      li.
        #[+Term--YDID オプション]が規定値が有る場合、#[+ImportantEntity__Code--YDID defaultValue]#[+Term--YDID プロパティ]を
          #[+Keyphrase--YDID 該当している#[+Term--YDID 型]の]値で指定しておこう。
        規定値が無い場合、#[+Keyword--YDID 代わりに]#[+ImportantEntity__Code--YDID required]と言う#[+Keyword--YDID 真偽型の]
          #[+Term--YDID プロパティ]を指定する#[+Keyword--YDID 必要]がある（無論、必須の場合は#[+ImportantEntity__Code--YDID true]）。
        但し、#[+Keyword--YDID 任意の]#[+Keyword__Contrast--YDID 真偽型の]#[+Term--YDID オプション]の場合、
          コンソールに明示的に入力されなかった値は明示的に入力された#[+ImportantEntity__Code--YDID false]も同然なので、
        #[+Term--YDID TypeScript]は#[+ImportantEntity__Code--YDID defaultValue]を指定#[+Keyword--YDID されない]。

      li.
        高品質なコードを目指しているが、説明書を読まない意味が分からないオプション名でも、利用者達の入力の便利さの為に短いオプション名にしたい場合、
          コードの整備者の為に仕様書を読まなくても和訳すれば意味が分かるオプション名を#[+ImportantEntity__Code--YDID newName]
          #[+Term--YDID プロパティ]に指定しておこう。

      li.
        #[+Term--YDID オプション]の為#[+Keyword--YDID 一文字の]の省略（#[+Term--YDID フラッグ]）を確保したい場合、望ましい省略を
          #[+ImportantEntity__Code--YDID shortcut]#[+Term--YDID プロパティ]に指定しておこう。
        コンソールへの入力の際、当文字の前に#[+Term--YDID ハイフン]を指定しなければいけないが、オプションの仕様を定義している今なら、ハイフンが無くても
          #[+Keyword--YDID 良い]です。

    p.Article-Paragraph.
      #[+Keyword--YDID 残りの]#[+Term--YDID プロパティ]は#[+Keyword--YDID 皆]#[+Term--YDID オプション]の
        #[+Term__Contrast--YDID 型]に依ります。
      これらを考察しておこう。


    //- ─── 文字列型オプションの特別なプロパティ ─────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 5,
      text: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfStringOptions.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfStringOptions.$anchor
    }).Article-Heading5

    p.Article-Paragraph.
      現在、こう言った#[+Term--YDID プロパティ]が#[+Keyword--YDID 一件]#[+Keyword__Contrast--YDID しか]なく、即ち
        #[+ImportantEntity__Code--YDID allowedAlternatives]。
      #[+Keyword--YDID 文字列型の]#[+Term--YDID オプション]の#[+Term--YDID]値を有限の数の選択肢に制限したい場合、
        此の選択肢を#[+ImportantEntity__Code--YDID allowedAlternatives]#[+Term--YDID プロパティ]に#[+Term--YDID 配列]
        として指定すれば良い。

    //- ─── 数型オプションの特別なプロパティ ─────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 5,
      text: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfNumericOptions.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfNumericOptions.$anchor
    }).Article-Heading5

    dl.Article-DescriptionList

      dt #[+ImportantEntity__Code--YDID numbersSet]
      dd

        | #[+Term--YDID 数の集合]、此の#[+Term--YDID オプションの型]にとって#[+Keyword--YDID 必須な]#[+Term--YDID プロパティ]である。
        | 値は当ライブラリ主要なパッケージから再利用された#[+ImportantEntity__Code--YDID RawObjectDataProcessor.NumbersSets]
        |   #[+Term--YDID 列挙]#[+Keyword--YDID でなければいけません]。

        dl.Article-DescriptionList
          dt #[+ImportantEntity__Code--YDID naturalNumber]
          dd 自然数

          dt #[+ImportantEntity__Code--YDID nonNegativeInteger]
          dd 正の整数

          dt #[+ImportantEntity__Code--YDID negativeInteger]
          dd 負の整数

          dt #[+ImportantEntity__Code--YDID negativeIntegerOrZero]
          dd 負の整数・0

          dt #[+ImportantEntity__Code--YDID anyInteger]
          dd 正負不問の整数

          dt #[+ImportantEntity__Code--YDID positiveDecimalFraction]
          dd 正の小数

          dt #[+ImportantEntity__Code--YDID negativeDecimalFraction]
          dd 負の小数

          dt #[+ImportantEntity__Code--YDID decimalFractionOfAnySign]
          dd 正負不問の小数

          dt #[+ImportantEntity__Code--YDID anyRealNumber]
          dd 実数

      dt #[+ImportantEntity__Code--YDID minimalValue]
      dd 大小限

      dt #[+ImportantEntity__Code--YDID maximalValue]
      dd 最大限


    //- ─── オブジェクト型オプションの特別なプロパティ ───────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 5,
      text: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfObjectOptions.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.
          consoleApplicationSpecification.$children.
          optionsSpecification.$children.
          specialPropertiesOfObjectOptions.$anchor
    }).Article-Heading5

    p.Article-Paragraph.
      現在こう言った#[+Term--YDID プロパティ]が#[+Keyword--YDID 一つ]#[+Keyword__Contrast--YDID しか]なくて、
        #[+ImportantEntity__Code--YDID validValueSpecification]と言い、#[+Keyword--YDID 必須]である。
      此れで#[+Term--YDID JSON5形式]の#[+Term__Contrast--YDID 文字列]が変換されるオブジェクトの使用を定義する必要が有る。

    p.Article-Paragraph
      | 当#[+Term--YDID プロパティ]は
      |
      //- TODO Replace to internal link once ready
      +Link--YDF({
        endorsedExternalURI: "https://github.com/TokugawaTakeshi/Yamato-Daiwa-ES-Extensions/blob/master/CoreLibrary/Package/Documentation/RawObjectDataProcessor/RawObjectDataProcessor.md#propertiesspecification-and-related---object-properties-specification"
      }).Article-Link RawObjectDataProcessor.PropertiesSpecification型
      |   と成り、主要パッケージから再利用され、#[+Term--YDID コマンドフレーズ]の#[+Term__Contrast--YDID オプション]の定義に似ているが、
      |   #[+ImportantEntity--YDID RawObjectDataProcessor]#[+Term--YDID クラス]の#[+Term__Contrast--YDID API]
      |   が使われている。


    //- ─── ④　コンソールコマンド処理ロジックの作成 ────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.logic.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.logic.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      コンソールアプリケーションの仕様の定義が完了し、此れを入力されたコンソールコマンドの処理のに使われる様に成った。
      其の為、#[+ImportantEntity--YDID ConsoleCommandsParser]#[+Term--YDID クラス]の#[+Keyword--YDID 静的]#[+Term--YDID メソッド]
        #[+ImportantEntity__Code--YDID parse]を呼び出す事。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        import { ConsoleCommandsParser } from "@yamato-daiwa/es-extensions-nodejs";
        import ApplicationConsoleLineInterface from "./ConsoleLineInterface";

        const parsedConsoleCommand: ConsoleCommandsParser.
            ParsedCommand<ApplicationConsoleLineInterface.SupportedCommandsAndParametersCombinations> =
            ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

    ul.Article-UnorderedList

      li.
        直近の段階で定義されたアプリケーションコマンドの資料は#[+Keyword--YDID 必須]の#[+Term--YDID 引数]である。

      li.
        #[+ImportantEntity--YDID ２引数目]を指定しない限り、#[+ImportantEntity__Code--YDID process.argv]は#[+Term--YDID 引数ベクトル]
          として使われる。

      li.
        #[+ImportantEntity--YDID ２段階目]に定義された#[+SecondaryEntity__Code--YDID SupportedCommandsAndParametersCombinations]
          と言う#[+Term--YDID TypeScript]#[+Term--YDID ユニオン]#[+Term__Contrast--YDID をジェネリック引数]として渡す事。

    p.Article-Paragraph.
      続き、具体的に何方の#[+Term--YDID コマンドフレーズ]が入力されたか、判断する目的。
      尚、安全に（#[+ImportantEntity__Code--YDID any]#[+Term--YDID 型]・#[+ImportantEntity--YDID TypeScript]エラー無し）
        該当している#[+Term--YDID オプション]にアクセス出来る様にしなけれないけない（但し、規定値が無い#[+Keyword--YDID 任意な]
        #[+Term--YDID オプション]はどうしても利用の前#[+Term--YDID 非undefined確認]が#[+Keyword--YDID 必要]）。
      #[+ImportantEntity__Code--YDID switch/case]は此の様な場合に取って丁度良い。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        switch (parsedConsoleCommand.phrase) {

          case ApplicationConsoleLineInterface.CommandPhrases.projectBuilding: {
            console.log("Build project", parsedConsoleCommand);
            console.log("requiredStringOption", parsedConsoleCommand.requiredStringOption);
            console.log("optionalStringOption", parsedConsoleCommand.optionalStringOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.packingOfBuild: {
            console.log("Pack project", parsedConsoleCommand);
            console.log("enumerationLikeStringOption", parsedConsoleCommand.enumerationLikeStringOption);
            console.log("numericOption", parsedConsoleCommand.numericOption);
            console.log("limitedNumericOption", parsedConsoleCommand.limitedNumericOption);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.projectDeploying: {
            console.log("Deploy project", parsedConsoleCommand);
            console.log("booleanOption", parsedConsoleCommand.booleanOption);
            console.log("JSON5_Option", parsedConsoleCommand.JSON5_Option);
            break;
          }

          case ApplicationConsoleLineInterface.CommandPhrases.referenceGenerating: {
            console.log(ConsoleCommandsParser.generateFullHelpReference(ApplicationConsoleLineInterface.specification));
          }

        }


    //- ─── ⑤ 名前でアプリケーションを実行 ─────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.stepwiseGuide.$children.launchingOfApplicationByName.$heading,
      HTML_ID: localizedSectioning.stepwiseGuide.$children.launchingOfApplicationByName.$anchor
    }).Article-Heading3

    p.Article-Paragraph
      | 現在、アプリケーションが#[+Keyphrase--YDID ファイルパスを指定し]
      |
      +Link--YDF({ unendorsedExternalURI: sharedExternalLinks.tsNode.homePage.top }).Article-Link ts-node
      |   で既に実行出来る、例えば

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        ts-node EntryPoint.test.ts --requiredStringOption test --optionalStringOption sample

    p.Article-Paragraph.
      過半数の読者達は#[+Term--YDID コマンド]（混乱させてはいるが、汎用な用語に依るとアプリケーション名を意味する）でアプリケーションを実行したいだろうから、
        上記の実行方法で満足しないはずだが、上記の方法が十分だから以前の手順で終了の場合を手短に考察しておこう。
      先ずは、開発対象の#[+Term--YDID コンソールインターフェース]は単一のプロジェクトにしか使わない予定で、#[+ImportantEntity--YDID npm]が、
        別の方法で公開する予定も場合である。
      特に、

    dl.Article-DescriptionList

      dt サーバアプリケーションを
      dd.
        普通だと、サーバを実行する単一の#[+Term--YDID コマンドフレーズ]しかなく、#[+Term--YDID オプション]で#[+Term--YDID HTTPポート]番号や
          ロギングレーベル等が指定される。

      dt 自動化専用スクリプト
      dd.
        普通はファイル生成・コピー・自動改善の様な課題で、但し#[+ImportantEntity--YDID Gulp]の様に一般手段が役に立たない程特別な目的である。

    p.Article-Paragraph.
      上記は一旦宜しいが、#[+SecondaryEntity--YDID gulp]や#[+SecondaryEntity--YDID webpack]の様に、#[+Term--YDID 名前]で
        コンソールアプリケーションを実行するにはどうすれば良いだろう。

    p.Article-Paragraph.
      先ずは、#[+ImportantEntity--YDID Node.js]#[+Term--YDID ランタイム]は#[+ImportantEntity--YDID TypeScript]に対応
        #[+Term--YDID されていない]ので、#[+Term--YDID ソースコード]を#[+ImportantEntity--YDID JavaScript]に
        #[+Term--YDID トラスパイル]#[+Keyword--YDID しなければいけない]。
      #[+ImportantEntity--YDID TypeScript]パッケージ#[+Term--YDID のコンソールインターフェース]でも実現出来るし、例に出た
        #[+ImportantEntity--YDID Webpack]でも活用すれば良い（但し#[+ImportantEntity--YDID TypeScript]専用のプラグインが
        必要に成る）。

    p.Article-Paragraph.
      然し、#[+Term--YDID トランスパイリング]を実行する前に、#[+Term--YDID エントリーポイント]からアプリケーションの論理を実行する#[+Term--YDID 関数]か
        #[+Term--YDID クラス]をエクスポート#[+Keyword--YDID しなければいけない]。
      「エントリーポイントからエクスポートする」事は、普通だと可笑しいだろう。
      理由としては、#[+Keyphrase--YDID コンソールアプリケーションの場合]、#[+Term--YDID エントリーポイント]は直接実行されるのでは#[+Keyword--YDID なく]、
        #[+Term--YDID 実行ファイル]を#[+Keyword--YDID 介して]実行されるのだ。
      下記の例では##[+SecondaryEntity__Code--YDID executeApplication]#[+Term--YDID 関数]をエクスポートする
        #[+Term--YDID エントリーポイント]。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript
      }): :code_listing--yda
        import { ConsoleCommandsParser } from "@yamato-daiwa/es-extensions-nodejs";
        import ApplicationConsoleLineInterface from "./ConsoleLineInterface";


        export function executeApplication(): void {

          const parsedConsoleCommand: ConsoleCommandsParser.
              ParsedCommand<ApplicationConsoleLineInterface.SupportedCommandsAndParametersCombinations> =
              ConsoleCommandsParser.parse(ApplicationConsoleLineInterface.specification);

          switch (parsedConsoleCommand.phrase) {

            case ApplicationConsoleLineInterface.CommandPhrases.projectBuilding: {
              // ...
              break;
            }

            case ApplicationConsoleLineInterface.CommandPhrases.packingOfBuild: {
              // ...
              break;
            }

            case ApplicationConsoleLineInterface.CommandPhrases.projectDeploying: {
              // ...
              break;
            }

            case ApplicationConsoleLineInterface.CommandPhrases.referenceGenerating: {
              console.log(ConsoleCommandsParser.generateFullHelpReference(ApplicationConsoleLineInterface.specification));
            }

          }

        }

    p.Article-Paragraph.
      #[+Keyword--YDID ソース]コードの#[+ImportantEntity--YDID JavaScript]への変換が終わり次第、手動で下記の様な内容のファイルを作ろう（例えば、
        #[+SecondaryEntity--YDID Executable.js]）。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JavaScript
      }): :code_listing--yda
        #!/usr/bin/env node

        require("./EntryPoint").executeApplication();

    p.Article-Paragraph.
      此処で一行目は#[+Term--YDID シバン]を含み、此のファイルを#[+ImportantEntity--YDID Node.js]で実行しなければいけない指定の役割。
      次は、アプリケーションを実行する関数（上記の例だと#[+SecondaryEntity__Code--YDID executeApplication]）をインポートし呼び出す。

    +QuestionAndAnswerBox--YDF({
      type: QuestionAndAnswerBox__YDF.Types.question,
      question: "このファイルをエントリーポイントにすれば良いじゃない？シバンを除き、一般JavaScriptファイルはずだ。"
    }).
      可能ではあり、規約だけの問題。
      普通は、行言った実行ファイルには、単一の関数かメソッドの呼び出しより複雑な倫理を保管する事が避けられる。
      とは言え、推薦に過ぎないので、守っている開発者もいて（例えば、#[+SecondaryEntity--YDID Gulp]の開発者）、守っていない開発者も要る（例えば
        #[+SecondaryEntity--YDID Webpack]の開発者、最終の確認は2024年の春）。

    p.Article-Paragraph.
      続き、上記の#[+Term--YDID 実行ファイル]に貴方プロジェクトの#[+ImportantEntity__Code--YDID package.json]から参照
        #[+Keyword--YDID しなければいけない]。
      コンソールアプリケーションを#[+Term--YDID 名前]で呼び出せる様に成るには、#[+ImportantEntity__Code--YDID bin]#[+Term--YDID フィルド]を
        #[+Keyword--YDID 連想配列系の]の#[+Term--YDID オブジェクト]で埋めなければいけない、但し#[+Keyword--YDID キー]は
        #[+Keyword--YDID コマンド]であり、#[+Keyword--YDID 値]は該当している#[+Term--YDID 実行ファイル]への#[+Keyword--YDID 相対]
        #[+Term--YDID パス]（#[+Term--YDID ファイル名拡張]#[+Keyword--YDID 無し]でも可能）。

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({
        codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON
      }): :code_listing--yda
        {
          // ...
          "bin": {
            "my_app": "Executable"
          },
          // ...
        }

    p.Article-Paragraph
      | #[+ImportantEntity__Code--YDID bin]#[+Term--YDID フィルド]に就いてもっと詳しい情報を
      |
      +Link--YDF({
        unendorsedExternalURI: sharedExternalLinks.npm.packageJSON.bin
      }).Article-Link npmのオフィシャル説明サイト
      | で確認可能。

    p.Article-Paragraph
      | 貴方のユーティリティを他のプロジェクトに導入するには、#[+ImportantEntity__Code--YDID name]や
      |   #[+ImportantEntity__Code--YDID version]の様に、追加で#[+ImportantEntity--YDID package.json]の#[+Term--YDID フィルド]
      |   を記入#[+Keyword--YDID しなけければいけない]。
      | 尚、#[+ImportantEntity--YDID npm]でユーティリティを公開したい場合、更に多くの#[+Term--YDID フィルド]を記入するべき。
      | #[+ImportantEntity--YDID npm]のオフィシャルサイトでは、
      +Link--YDF({
        unendorsedExternalURI: sharedExternalLinks.npm.guides.minimalPackageJSON
      }).Article-Link 関連している案内
      | が有る。

    //-
      p.Article-Paragraph
        | 貴方のユーティリテを含む#[+Term--YDID npmパッケージ]を別のプロジェクトに導入するには、複数の方法が有る。
        | #[+ImportantEntity--YDID npm]上公開された場合、#[+ImportantEntity__Code--YDID npm install &lsqb;package_name&rsqb;]
        |   で導入可能に成り、
        +Link--YDF({
          unendorsedExternalURI: sharedExternalLinks.stackOverflow.installationOfLocalNPM_PackageByRelativePath
        }).Article-Link 相対パス
        | や#[+Term--YDID バージョン管理システム]の
        +Link--YDF({
          unendorsedExternalURI: sharedExternalLinks.stackOverflow.installationOfNPM_PackageByCommitNumber
        }).Article-Link コミットに参照
        | する事も可能。
        | 何れかの方法でユーティリテを別のプロジェクトに導入すれば、下記の様に当プロジェクトの#[+ImportantEntity--YDID package.json]で宣言された
        |   #[+Term--YDID npmスクリプト]を介して、呼び出す事が出来る様に成る。

      +CodeViewer--YDF
        +CodeViewer-Listing--YDF({
          codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON
        }): :code_listing--yda
          {
            // ...
            "scripts": {
              "example": "my_app --option1 alpha --flag"
            },
            // ...
          }

      p.Article-Paragraph.
        とか言え、此れで又多くの方が満足されなく、下記の様に名前で直接コンソールから呼び出したいからだ。

      +CodeViewer--YDF
        +CodeViewer-Listing--YDF({
          codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.Bash
        }): :code_listing--yda
          my_app --option1 alpha --flag
