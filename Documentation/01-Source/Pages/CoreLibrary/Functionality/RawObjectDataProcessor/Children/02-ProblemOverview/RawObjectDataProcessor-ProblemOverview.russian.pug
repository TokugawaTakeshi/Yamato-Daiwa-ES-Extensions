extends ../../../../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../../../../SharedAssets/Markup/SharedAssets.russian.pug
  include ../../../../../../SharedComponents/SharedComponents.russian.pug


block append Metadata

  -

    const {
      $heading: topHeading,
      $sectioning: localizedSectioning
    } = localizedRouting.coreLibrary.$children.functionality.$children.RawObjectDataProcessor.$children.problemOverview;

    RegularWebPageTemplate__YDF.configure({
      metadata: {
        title: buildHTML_PageTitle(`RawObjectDataProcessor — ${ topHeading }`),
        description: ""
      },
      stylesSheetsURIs: [
        "$CommonStyles",
        "$LayoutsStyles/TwoColumns/TwoColumnsLayout.css",
        "$PreMadesStyles",
        "@CustomizedExternalComponents"
      ]
    });

    RoutingEmulator.setCurrentRoute("coreLibrary.functionality.RawObjectDataProcessor.problemOverview");

    LanguageDropDownList__YDF_DK.setLinks({
      english: routing.english.coreLibrary.$children.functionality.$children.RawObjectDataProcessor.$children.problemOverview.$URI,
      japanese: routing.japanese.coreLibrary.$children.functionality.$children.RawObjectDataProcessor.$children.problemOverview.$URI
    });


block append HeadScripts

  if __IS_PRODUCTION_BUILDING_MODE__

    +GoogleAnalyticsScript


block append SpecificContent

  article

    //- ━━━ `RawObjectDataProcessor` — Обзор проблематики ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    h1.Article-Heading1!= `<code>RawObjectDataProcessor</code> — ${ topHeading }`

    p.Article-Paragraph.
      Работа с #[+Keyword--YDID неизвестными] #[+Term--YDID заранее] #[+Keyphrase--YDID внешними] данными — одна из
        #[+Keyword--YDID базовых] задач программирования.
      Такими внешними данными могут быть:

    ul.Article-UnorderedList
      li Данные, полученные с клиентской части в клиент-серверном взаимодействии
      li Наоборот, данные с серверной части в клиент-серверном взаимодействии
      li Данные из базы данных
      li Данные из файла (#[+SecondaryEntity--YDID JSON], #[+SecondaryEntity--YDID YAML] и подобных)

    p.Article-Paragraph.
      Поскольку такие данные находятся вне досягаемости #[+ImportantEntity--YDID TypeScript], то
        #[+Keyword--YDID изначально] имеют #[+Term--YDID тип] #[+ImportantEntity__Code--YDID unknown] или, что ещё хуже,
        #[+ImportantEntity__Code--YDID any].

    p.Article-Paragraph.
      Как обычно действуют в данной ситуации?
      К сожалению, зачастую не так, как надлежит при написании качественного кода.
      Если при получении данных с клиентской части при клиент-серверном взаимодействии #[+Term--YDID валидация] данных
        считается #[+Keyphrase--YDID мерой безопасности], а потому осуществляется, то во многих других случаях, например
        при получении данных с сервера этим данным просто доверяют, а потому помечают их желаемым типом:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        type User = {
          ID: string;
          familyName: string;
          givenName: string;
        };


        fetch("http://example.com/users/1").
            then((response: Response): void => response.json()).
            then((data: unknown) => {

              // Это пример ПЛОХОГО кода. НЕ ПОДРАЖАЙТЕ ЕМУ!!!
              const user: User = data as User;

              const fullName: string = `${user.givenName} ${user.familyName}`;
              console.log(fullName);

            });

    p.Article-Paragraph.
      Как показывает практика, #[+Keyphrase--YDID в подавляющем большинстве] проектов среднего и крупного масштабов
        случается расхождение между ожидаемыми и реальными данными, особенно если клиентская и серверная часть
        разрабатываются на разных языках программирования и отдельными командами.
      Число таких расхождений может быть очень большим — от нескольких десятков до нескольких сотен и даже тысяч.
      Причиной тому может быть как элементарный человеческий фактор, так и отсутствие своевременного уведомления
        причастных инженеров об изменении в данных.

    p.Article-Paragraph.
      А если Вы создаёте какую-либо утилиту с декларативной конфигурацией через файл
        (обычно #[+ImportantEntity--YDID JSON], #[+ImportantEntity--YDID YAML] и т. д.) наподобие
        #[+SecondaryEntity__Code--YDID docker compose], то там неверно указанная конфигурация является
        #[+Keyword--YDID обычным] сценарием.
      Поэтому перед тем, как работать в внешними данными, их #[+Keyword--YDID необходимо] валидировать, то есть проверить,
        соответствуют ли реальные данные установленным ограничениям.


    //- ━━━ Подходы без использования библиотек ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.nativeApproaches.$heading,
      HTML_ID: localizedSectioning.nativeApproaches.$anchor
    }).Article-Heading2

    p.Article-Paragraph.
      #[+Term--YDID Защитники типов] — #[+Keyword--YDID нативная] функциональность #[+ImportantEntity--YDID TypeScript].
      #[+Term--YDID Защитники типов] представляют собой #[+Term--YDID функции], возвращающие
        #[+Keyword--YDID булевское] значение, при этом возвращаемое значение аннотируется #[+Keyword--YDID не]&nbsp;как
        #[+ImportantEntity__Code--YDID boolean], а наподобие #[+ImportantEntity--YDID x is T], где
        #[+ImportantEntity--YDID x] — #[+Term--YDID параметр], #[+Term__Contrast--YDID тип] которого предстоит
        проверить, #[+ImportantEntity--YDID T] — желаемый #[+Term--YDID тип]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        type User = {
          ID: string;
          familyName: string;
          givenName: string;
        };

        function isUser(rawData: unknown): rawData is User {
          return typeof rawData === "object" &&
              rawData !== null &&
              "ID" in rawData && rawData.ID === "string" &&
              "familyName" in rawData && rawData.familyName === "string" &&
              "givenName" in rawData && rawData.givenName === "string";
        }

    p.Article-Paragraph
      | Помимо
      |
      +Link--YDF({
        unendorsedExternalURI: "https://www.typescriptlang.org/docs/handbook/advanced-types.html"
      }) документации TypeScript,
      |
      | #[+Term--YDID защитники типов] были хорошо разобраны в
      |
      +Link--YDF({ unendorsedExternalURI: "https://mariusschulz.com/blog/the-unknown-type-in-typescript" }) статье
      |
      | фронтенд-иженера #[+Link--YDF({ unendorsedExternalURI: "https://mariusschulz.com/about" }) Marius Schulz].
      | Для нас важно что:

    +AdmonitionBlock--YDF({
      SVG_Icon: true,
      geometricVariation: AdmonitionBlock__YDF.GeometricVariations.stickyNoteLike,
      decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.error
    }).
      Защитники типов #[+Keyword--YDID не]&nbsp;гарантируют, что в случае возврата #[+ImportantEntity__Code--YDID true]
        #[+Keyword--YDID реальный] #[+Term--YDID тип] параметра будет соответствовать желаемому — это лишь
        #[+Keyword--YDID просьба] #[+ImportantEntity--YDID TypeScript]-у поверить, что это так.
      В реальности же всё то, что осуществляются в #[+Term--YDID теле] #[+Term__Contrast--YDID функции-защитника],
        #[+Keyphrase--YDID может вообще #[+Keyword--YDID не]&nbsp;иметь никакого отношения к желаемому #[+Term--YDID типу]].

    p.Article-Paragraph.
      Вот пример #[+Keyword--YDID ошибочного] кода, в котором #[+Term--YDID защитник]
        #[+SecondaryEntity__Code--YDID isUser] #[+Term--YDID типа] #[+SecondaryEntity__Code--YDID User] проверят у
        #[+Term--YDID параметра] те #[+Term__Contrast--YDID поля], которые вообще #[+Keyword--YDID не]&nbsp;имеют
        отношения к желаемому #[+Term--YDID типу] #[+SecondaryEntity--YDID User]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        type User = {
          ID: string;
          familyName: string;
          givenName: string;
        };

        // НАМЕРЕННО ОШИБОЧНЫЙ ПРИМЕР!!!
        function isUser(rawData: unknown): rawData is User {
          return typeof rawData === "object" &&
              rawData !== null &&
              "title" in rawData && rawData.title === "string" &&
              "price" in rawData && rawData.price === "string";
        }


        const potentialUser: unknown = { title: "Shampoo", price: 1000 };

        if (isUser(potentialUser)) {
          console.log(potentialUser.familyName);
        }

    p.Article-Paragraph.
      Несмотря на то, что содержимое #[+Term--YDID переменной] #[+SecondaryEntity__Code--YDID potentialUser] и близко
        не&nbsp;имеет отношение к типу #[+SecondaryEntity__Code--YDID User], #[+SecondaryEntity__Code--YDID isUser]
        вернёт #[+SecondaryEntity__Code--YDID true] и #[+ImportantEntity--YDID TypeScript]
        #[+Keyphrase--YDID даже не&nbsp;заподозрит, что что-то не&nbsp;так].
      Более того, #[+ImportantEntity--YDID TypeScript] не&nbsp;выразит не&nbsp;малейшего недовольства, если в
        #[+Term--YDID теле] #[+Term__Contrast--YDID функции-защитника] вообще ничего не&nbsp;будет проверяться:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        type User = {
          ID: string;
          familyName: string;
          givenName: string;
        };

        // НАМЕРЕННО ОШИБОЧНЫЙ ПРИМЕР!!!
        function isUser(rawData: unknown): rawData is User {
          console.log(rawData);
          return Math.random() >= 0.5;
        }

    p.Article-Paragraph.
      Почему же всё так плохо?
      Если кратко, то из-за #[+Keyword--YDID фундаментальных] ограничений #[+ImportantEntity--YDID TypeScript].
      Валидация данных (в том числе с помощью #[+Term--YDID защитников типов]) осуществляется
        #[+Keyphrase--YDID во время выполнения #[+ImportantEntity--YDID JavaScript-а]], когда #[+Keyword--YDID исходного]
        #[+Term--YDID TypeScript-кода] #[+Keyword--YDID уже] #[+Keyword__Contrast--YDID нет].
      В #[+Keyword--YDID выходном] #[+Term--YDID JavaScript-коде] #[+Term--YDID защитник типов] — #[+Keyword--YDID уже]
        #[+Keyword__Contrast--YDID обычная] #[+Term--YDID JavaScript-функция], ничем
        #[+Keyword--YDID не]&nbsp;отличающаяся по своей природе от других #[+Term--YDID функций], возвращающих
        #[+Term--YDID булевское значение].

    p.Article-Paragraph.
      Такие особенности языка #[+ImportantEntity--YDID TypeScript], как #[+Term--YDID алиас типов]
        (#[+Term--YDID ключевое слово] #[+ImportantEntity__Code--YDID type]) или #[+Term--YDID интерфейсы] существуют
        #[+Keyword--YDID только] в рамках #[+Keyword--YDID исходного] #[+Term--YDID TypeScript-кода], но в
        #[+Keyword--YDID выходном] #[+Term--YDID JavaScript-коде] их нет, следовательно какого-либо способа сослаться
        на них #[+Keyword--YDID тоже] #[+Keyword__Contrast--YDID нет].
      #[+Keyword--YDID Теоретически], можно было бы реализовать генерацию вспомогательных #[+Term--YDID функций] и/или
        #[+Term__Contrast--YDID объектов] на основе #[+Term--YDID алиасов типов] и #[+Term--YDID интерфейсов] в исходном
        #[+Term--YDID TypeScript-коде], чтобы потом использовать их для валидации без ручного написания кода, однако
        #[+Keyword--YDID маловероятно], что команда разработки #[+ImportantEntity--YDID TypeScript] в ближайшем будущем
        реализует что-то подобное.

    p.Article-Paragraph.
      Помимо выше описанной, у #[+Term--YDID защитников типов] есть ещё #[+Keyword--YDID несколько]
        #[+Keyword__Contrast--YDID существенных] проблем:

    ul.Article-UnorderedList

      li.
        #[+Term--YDID Защитники типов] #[+Keyphrase--YDID по своей концепции] #[+Keyword--YDID только] отвечают на
          вопрос, валиден ли #[+Term--YDID параметр] или нет, при этом где именно имеются нарушения, сообщено
          #[+Keyword--YDID не]&nbsp;будет.

      li.
        #[+Term--YDID Защитник типов] вернёт #[+ImportantEntity__Code--YDID false] #[+Keyphrase--YDID при первом же]
          #[+Keyword--YDID ложном] условии, хотя могут быть и другие #[+Keyword--YDID ложные] условия.

    p.Article-Paragraph.
      Вообще-то говоря, эти проблемы являются таковым лишь #[+Keyword--YDID де-факто], потому что как уже было упомянуто
        выше, при реализации #[+Term--YDID защитников типов] #[+ImportantEntity--YDID TypeScript] требует
        #[+Keyword--YDID только] #[+Keyword__Contrast--YDID две] вещи: обязательного возврата
        #[+Term--YDID булевского значения] и особой аннотации возвращаемого #[+Term--YDID типа], а в
        #[+Term--YDID теле функции] можно реализовать #[+Keyphrase--YDID всё, что угодно], включая логирование,
        полную проверку всех #[+Term--YDID свойств] и так далее.
      Проблема лишь в том, что #[+Keyphrase--YDID в реальности] так #[+Keyword--YDID почти]
        #[+Keyword__Contrast--YDID никто] #[+Keyword--YDID не]&nbsp;делает, и на то есть веская причина.
      Если Вы #[+Keyphrase--YDID в реальном] (не&nbsp;учебном) проекте среднего или большого масштаба начать
        реализовывать #[+Term--YDID защитники типов] с выше перечисленной функциональностью, то очень быстро возникнет
        ещё одна неприятная проблема: слишком много рутинного кода, причём местами он почти одинаковый.
      Особенно это касается качественного логирования: будет много однотипных сообщений, и их придётся либо каждый раз
        писать заново, либо организовывать вынос сообщений в отельные объекты и/или файлы, пока не&nbsp;встанет вопрос
        о вынесении всего этого кода в библиотеку.
      А #[+Keyphrase--YDID в реальном] проекте объекты будут отнюдь не&nbsp;такие простые, как
        #[+SecondaryEntity--YDID User] из примера выше, а могу иметь по
        #[+SecondaryEntity--YDID 20]-#[+SecondaryEntity--YDID 30] свойств, и это не&nbsp;предел, причём часто будут и
        #[+Keyword--YDID вложенные] #[+Term--YDID объекты], в частности #[+Term--YDID массивы], и зачастую с
        #[+Term--YDID элементами] типа #[+Term--YDID «объект»], которые тоже надо валидировать.
      Обилие рутинного кода повышает вероятность ошибок из-за усталости, потому нативное решение задачи хотя имеется,
        но #[+Keyword--YDID не]&nbsp;является практичным.

    p.Article-Paragraph.
      Однако, это #[+Keyword--YDID не]&nbsp;делает #[+Term--YDID защитники типов] бесполезными — просто они плохо
        справляются с валидацией #[+Term--YDID объектов] #[+Keyphrase--YDID с большим количеством свойств], но для
        других типов значений (#[+Term--YDID строки], #[+Term--YDID числа] и так далее) они
        #[+Keyword--YDID не]&nbsp;просто подходят, но обычно используются в большом количестве.
      #[+ImportantEntity--YDID YDEE] также предлагает набор #[+Term--YDID защитников типов], многие из которых
        используются и внутри библиотеки:

    +CompactTableOfContents--YDF_DK(localizedRouting.coreLibrary.$children.functionality.$children.typeGuards.$sectioning)


    //- ━━━ Подход `RawObjectDataProcessor` ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      innerHTML: localizedSectioning.rawObjectDataProcessorApproach.$heading,
      HTML_ID: localizedSectioning.rawObjectDataProcessorApproach.$anchor
    }).Article-Heading2

    p.Article-Paragraph.
      Итак, ввиду того что при #[+Term--YDID транспайлинге] #[+ImportantEntity--YDID TypeScript] в
        #[+ImportantEntity--YDID JavaScript] #[+Term--YDID интерфейсы] и #[+Term--YDID алиасы типов] (
        #[+Term--YDID ключевое слово] #[+ImportantEntity--YDID type]) прекращают своё существование,
        на них во время выполнения #[+Term--YDID JavaScript-кода] сослаться #[+Keyword--YDID никак]
        #[+Keyword__Contrast--YDID нельзя], потому исчерпывающе доказать, что конкретный #[+Term--YDID объект] имеет
        конкретный тип #[+Keyword--YDID невозможно] — ведь даже если есть соответствующий #[+Term--YDID защитник типа],
        находящаяся внутри него логика может вообще #[+Keyword--YDID не]&nbsp;иметь отношения к проверке на нужные
        #[+Term--YDID свойства].
      Однако перед тем, как использовать ключевое слово #[+ImportantEntity__Code--YDID as], следует это использование
        чем-либо #[+Keyword--YDID подкрепить], а именно валидацией, при этом в целях #[+Term--YDID поддерживаемости]
        валидатор должен детально логировать #[+Keyword--YDID все] несоответствия установленным,
        а #[+Keyphrase--YDID не&nbsp;только первое из них].
      При таком раскладе, даже если указанные правил валидации и #[+Keyword--YDID не]&nbsp;будут соответствовать
        реальному типу (например, из-за допущенной по усталости ошибки), как показывает практика, это очень быстро
        обнаруживается.

    p.Article-Paragraph
      | Таким образом, #[+ImportantEntity--YDID RawObjectDataProcessor] берёт на себя #[+Keyword--YDID грех] использования
      |   #[+ImportantEntity--YDID as], требуя взамен указать спецификацию валидных данных почти что в декларативном
      |   виде.
      | Рассмотрим ещё раз
      |
      +Link--YDF({
        internalURI: localizedRouting.coreLibrary.$children.functionality.$children.RawObjectDataProcessor.
            $children.demo.$URI
      }) демо
      |   в свете описанной выше теории.

        function onDataRetrieved(externalData: unknown): void {

          const externalDataProcessingResult: RawObjectDataProcessor.ProcessingResult<SampleType> = RawObjectDataProcessor.
              process(
                externalData,
                {
                  nameForLogging: "Example",
                  subtype: RawObjectDataProcessor.ObjectSubtypes.fixedSchema,
                  properties: {
                    foo: {
                      type: Number,
                      isUndefinedForbidden: true,
                      isNullForbidden: true,
                      numbersSet: RawObjectDataProcessor.NumbersSets.positiveIntegerOrZero
                    },
                    bar: {
                      type: String,
                      isUndefinedForbidden: true,
                      isNullForbidden: true,
                      minimalCharactersCount: 5
                    },
                    baz: {
                      type: Boolean,
                      isUndefinedForbidden: true,
                      isNullForbidden: true
                    },
                    hoge: {
                      type: Number,
                      isUndefinedForbidden: false,
                      isNullForbidden: true,
                      numbersSet: RawObjectDataProcessor.NumbersSets.positiveIntegerOrZero
                    },
                    fuga: {
                      type: Number,
                      isUndefinedForbidden: true,
                      isNullForbidden: false,
                      numbersSet: RawObjectDataProcessor.NumbersSets.positiveIntegerOrZero
                    },
                    quux: {
                      type: Object,
                      isUndefinedForbidden: true,
                      isNullForbidden: true,
                      properties: {
                        alpha: {
                          type: Number,
                          isUndefinedForbidden: true,
                          isNullForbidden: true,
                          numbersSet: RawObjectDataProcessor.NumbersSets.anyInteger,
                          minimalValue: 3
                        },
                        bravo: {
                          type: String,
                          isUndefinedForbidden: true,
                          isNullForbidden: true,
                          minimalCharactersCount: 5,
                          allowedAlternatives: [ "PLATINUM", "GOLD", "SILVER" ]
                        }
                      }
                    }
                  }
                }
              );

        }

    p.Article-Paragraph.
      Сначала #[+ImportantEntity--YDID RawObjectDataProcessor] проверит, соответствует ли реальное значение
        #[+SecondaryEntity__Code--YDID externalData] спецификации, переданной через второй параметр.
      Как и обычный #[+Term--YDID защитник типов], #[+ImportantEntity--YDID RawObjectDataProcessor] программно
        проверяет свойства, однако если что-то не так, то не прекращает проверку немедленно (за исключением случаев,
        когда сам #[+SecondaryEntity__Code--YDID externalData] не является объектом), а сохраняет сообщение о
        несоответствии в #[+SecondaryEntity__Code--YDID externalDataProcessingResult.validationErrorsMessages]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        if (externalDataProcessingResult.isRawDataInvalid) {

          throw new InvalidExternalDataError({
            mentionToExpectedData: "N External Data",
            messageSpecificPart: RawObjectDataProcessor.
                formatValidationErrorsList(externalDataProcessingResult.validationErrorsMessages)
          });

        }
