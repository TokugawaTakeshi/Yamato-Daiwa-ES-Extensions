extends ../../../../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../../../../SharedAssets/Markup/SharedAssets.russian.pug
  include ../../../../../../SharedComponents/SharedComponents.russian.pug


block append Metadata

  -

    const {
      $heading: topHeading,
      $sectioning: localizedSectioning
    } = localizedRouting.coreLibrary.$children.functionality.$children.RawObjectDataProcessor.$children.theoreticalMinimum;

    RegularWebPageTemplate__YDF.configure({
      metadata: {
        title: buildHTML_PageTitle(`RawObjectDataProcessor — ${ topHeading }`),
        description: ""
      },
      stylesSheetsURIs: [
        "$CommonStyles",
        "$LayoutsStyles/TwoColumns/TwoColumnsLayout.css",
        "$PreMadesStyles",
        "@CustomizedExternalComponents"
      ]
    });

    RoutingEmulator.setCurrentRoute("coreLibrary.functionality.RawObjectDataProcessor.theoreticalMinimum");

    LanguageDropDownList__YDF_DK.setLinks({
      english: routing.english.coreLibrary.$children.functionality.$children.RawObjectDataProcessor.$children.theoreticalMinimum.$URI,
      japanese: routing.japanese.coreLibrary.$children.functionality.$children.RawObjectDataProcessor.$children.theoreticalMinimum.$URI
    });


block append HeadScripts

  if __IS_PRODUCTION_BUILDING_MODE__

    +GoogleAnalyticsScript


block append SpecificContent

  article

    //- ━━━ `RawObjectDataProcessor` — Теоретический минимум ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    h1.Article-Heading1!= `<code>RawObjectDataProcessor</code> — ${ topHeading }`

    p.Article-Paragraph.
      При работе в #[+ImportantEntity--YDID RawObjectDataProcessor] необходимо учитывать некоторые нюансы
        #[+ImportantEntity--YDID JavaScript]/#[+ImportantEntity--YDID TypeScript], а вернее, стандарта
        #[+ImportantEntity--YDID ECMAScript] и связанных с ним.
      Такие нюансы, разумеется, документированы в официальных и неофициальных источниках, однако начинающие программисты
        которых немало их часто не&nbsp;знают.


    //- ━━━ Классификация объектных данных ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.objectLikeDataClassification.$heading,
      HTML_ID: localizedSectioning.objectLikeDataClassification.$anchor
    }).Article-Heading2

    p.Article-Paragraph.
      Как видно из названия #[+ImportantEntity--YDID «RawObjectDataProcessor»], этот утилитарный #[+Term--YDID класс]
        предназначен для работы с #[+Keyword--YDID объектными] данными, то есть данными, удовлетворяющими условию
        #[+ImportantEntity--YDID typeof N === "object"], при этом #[+Keyword--YDID не]&nbsp;являющимися
        #[+ImportantEntity__Code--YDID null] (а #[+ImportantEntity__Code--YDID typeof null] #[+Keyword--YDID тоже]
        является #[+ImportantEntity__Code--YDID "object"]
        #[+Keyphrase--YDID с точки зрения стандарта #[+ImportantEntity--YDID ECMAScript]]).
      Однако, #[+Keyword--YDID дочерние] #[+Term--YDID свойства] могут иметь и другие типы:
        #[+ImportantEntity__Code--YDID Number], #[+ImportantEntity__Code--YDID String],
        #[+ImportantEntity__Code--YDID Boolean],
      Тем не менее, на данный момент #[+Keyword--YDID полностью] поддерживаются только #[+Keyword--YDID входные] данные,
        совместимые с #[+ImportantEntity--YDID JSON].
      Соответствующий #[+Term--YDID тип] имеет следующее определение:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        export type ParsedJSON = ParsedJSON_Object | ParsedJSON_Array;

        export type ParsedJSON_Object = { [key: string]: ParsedJSON_NestedProperty; };

        export type ParsedJSON_Array = Array<ParsedJSON_NestedProperty>;

        export type ParsedJSON_NestedProperty =
          number |
          string |
          boolean |
          null |
          ParsedJSON_Object |
          ParsedJSON_Array |
          undefined;

    +AdmonitionBlock--YDF({
      title: "JSON и объекты",
      SVG_Icon: true,
      areThemesCSS_ClassesCommon: true,
      geometricVariation: AdmonitionBlock__YDF.GeometricVariations.stickyNoteLike,
      decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.warning
    })

      p.Article-Paragraph.
        Хотя такие термины, как #[+Term--YDID «объекты»] и #[+Term--YDID «массивы»] часто применяются по отношению к
          #[+ImportantEntity--YDID JSON], необходимо понимать, что #[+ImportantEntity--YDID JSON] — это
          #[+Keyword--YDID строка], а #[+Keyword--YDID не]&nbsp;#[+Term--YDID объект].
        Именно поэтому приведённые выше имена #[+Term--YDID алиасов] начинаются с #[+Term--YDID «parsed»], а
          не&nbsp;просто #[+SecondaryEntity__Code--YDID JSON_Object] или #[+SecondaryEntity__Code--YDID JSON_Array].

      p.Article-Paragraph.
        В случае #[+Term--YDID ECMAScript-языков] для того, чтобы получить из #[+Term--YDID JSON-строки] обычный
          #[+Term--YDID объект], чаще всего используется #[+ImportantEntity__Code--YDID JSON.parse()].
        Но хотя формат #[+ImportantEntity--YDID JSON] и произошёл от #[+ImportantEntity--YDID JavaScript] (что понятно из
          расшифровки — #[+Term--YDID «JavaScript Object Notation»]), с этим форматом данных работают и большинство
          других популярных языков программирования, но там #[+Term--YDID JSON-строка] преобразуется в типы данных,
          поддерживаемые соответствующим языком программирования.

    p.Article-Paragraph.
      В будущем возможно будет добавлена поддержка и других #[+Term--YDID типов] #[+Keyword__Contrast--YDID дочерних]
        #[+Term--YDID свойств], например #[+ImportantEntity--YDID Date] или #[+ImportantEntity--YDID BigInt].
      Но на данный момент эта функциональность востребована мало, так как обычно при чтении данных из внешних источников
        и при образовании их в #[+Term--YDID JavaScript-объект] они совместимы с #[+ImportantEntity--YDID JSON], а
        если нужны свойства типа #[+ImportantEntity__Code--YDID Date] или #[+ImportantEntity__Code--YDID BigInt], то
        их можно преобразовать из строк в ходе постобработки.

    p.Article-Paragraph.
      Итак, #[+ImportantEntity--YDID RawObjectDataProcessor] работает со следующими #[+Keyword--YDID четырьмя] подтипами
        #[+Term--YDID объектов]:

    +Table--YDF({
      decorativeVariation: Table__YDF.DecorativeVariations.modestlyCalmingPastelSolid
    })

      thead

        tr

          th(scope="col") ↓ Тип ключей / ➝ Число элементов
          th(scope="col") Фиксированное
          th(scope="col") Произвольное

      tbody

        tr

          th(scope="row") Строковые
          td Объект фиксированной структуры
          td Ассоциативный массив

        tr

          th(scope="row") Неотрицательные целочисленные
          td Кортеж
          td Индексный массив



    //- ─── Объекты фиксированной структуры ────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.objectLikeDataClassification.$children.fixedSchema.$heading,
      HTML_ID: localizedSectioning.objectLikeDataClassification.$children.fixedSchema.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      Для этих подтипов #[+Term--YDID объектов] подразумевается, что имена #[+Keyword--YDID всех]
        #[+Keyword__Contrast--YDID возможных] #[+Term--YDID свойств] известны #[+Term--YDID заранее].
      #[+Term--YDID Тип] #[+SecondaryEntity__Code--YDID SampleType] из демо является примером такого подтипа
        #[+Term--YDID объектов]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        type SampleType = {
          foo: number;
          bar: string;
          baz: boolean;
          hoge?: number;
          fuga: string | null;
          quux: {
            alpha: number;
            bravo: "PLATINUM" | "GOLD" | "SILVER";
          };
        };

    p.Article-Paragraph.
      #[+Term--YDID Фиксированная структура] #[+Keyword--YDID не]&nbsp;является запретом на
        #[+Term--YDID полиморфные свойства], однако возможные варианты #[+Keyword--YDID должны] быть
        #[+Keyword--YDID заранее] известны, как в примере ниже.

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        type SampleTypeWithPolymopthocProperties = {
          foo:
              { hoge: string; } |
              { fuga: number: }
          bar: number:
          baz: string;
        };

    p.Article-Paragraph.
      Такой тип #[+Term--YDID объектов] является #[+Keyword--YDID наиболее] #[+Keyword__Contrast--YDID популярным],
        потому что чаще всего именно такое данные в сериализованном виде данные отправляются с клиента на сервер и
        наоборот.
      Такой же тип данный обычно представляют собой настройки, хранящиеся в файлах наподобие
        #[+ImportantEntity--YDID JSON], #[+ImportantEntity--YDID YAML] и так далее (например, конфигурация
        #[+SecondaryEntity--YDID TypeScript] — обычно #[+SecondaryEntity--YDID tsconfig.json]).


    //- ─── Объекты типа «ассоциативный массив» ────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.objectLikeDataClassification.$children.associativeArrays.$heading,
      HTML_ID: localizedSectioning.objectLikeDataClassification.$children.associativeArrays.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      #[+Term--YDID Ассоциативные массивы] в отличие от #[+Term--YDID объектов фиксированной структуры] могут иметь
        #[+Keyphrase--YDID произвольное] количество #[+Term--YDID свойств], имена которых #[+Keyword--YDID заранее]
        #[+SecondaryEntity__Code--YDID не]&nbsp;известны.

    p.Article-Paragraph.
      #[+Keyword--YDID До] стандарта #[+ImportantEntity--YDID ESMAScript 2015] в качестве таких #[+Term--YDID массивов]
        использовались #[+Keyword--YDID обычные] #[+Term--YDID объекты],
        #[+Keyphrase--YDID с точки зрения #[+Keyword--YDID выходного] #[+Term--YDID JavaScript-кода]]
        #[+Keyword--YDID ничем] #[+Keyword__Contrast--YDID не]&nbsp;отличающиеся от
        #[+Term--YDID объектов фиксированной структуры].
      В #[+ImportantEntity--YDID TypeScript] подобные #[+Term--YDID ассоциативные массивы] аннотируются
        #[+Keyphrase--YDID одним из] следующих способов:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        type AssociativeArray<ValueType> = { [ key: string ]: ValueType };

        // Или

        type AssociativeArray<ValueType> = Record<string, ValueType>;

    p.Article-Paragraph.
      Введённый в #[+Term--YDID стандарте] #[+ImportantEntity--YDID ESMAScript 2015] #[+Term--YDID тип данных]
        #[+ImportantEntity--YDID Map] можно или не&nbsp;нельзя называть #[+Term--YDID ассоциативным массивом] в
        зависимости от того, допускать ли у такого типа #[+Term--YDID массивов] #[+Term__Contrast--YDID ключи]
        #[+Keyword--YDID произвольного] типа (в частности, #[+ImportantEntity--YDID Map] не&nbsp;запрещает
        #[+Term--YDID объектные] #[+Term--YDID ключи]).
      Так или иначе, #[+Term--YDID тип данных] #[+ImportantEntity--YDID Map] #[+Keyword--YDID несовместим] с
        #[+ImportantEntity--YDID JSON], однако такой совместимости можно достичь, преобразовав
        #[+ImportantEntity--YDID Map] в #[+Keyphrase--YDID двумерный] #[+Term--YDID индексный массив], где
        #[+Keyphrase--YDID в каждом #[+Keyword--YDID дочернем]] массиве #[+Keyword--YDID первый] элемент —
        #[+Term--YDID ключ], а #[+Keyword--YDID второй] — #[+Term--YDID значение]:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        const sampleMap: Map<string, number> = new Map([
          [ "alpha", 1 ],
          [ "bravo", 2 ],
          [ "charlie", 3 ]
        ]);

        const serializedMap: string = JSON.stringify(Array.from(sampleMap.entries()));

    +AdmonitionBlock--YDF({
      title: "Осторожнее с терминологий",
      SVG_Icon: true,
      geometricVariation: AdmonitionBlock__YDF.GeometricVariations.stickyNoteLike,
      decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.warning
    }).
      Как по отношению к #[+Term--YDID объектам фиксированной структуры], так и к #[+Term--YDID ассоциативным массивам]
        применяются термины #[+Term--YDID «ключ»] и #[+Term--YDID «значение»].
      С #[+Term--YDID ключами] всё более-менее понятно, а термин #[+Term--YDID «значение»] слишком широкий, потому что
        он может применяться #[+Keyword--YDID вне]&nbsp;#[+Term--YDID объектов] по отношению к #[+Keyword--YDID любым]
        #[+Term--YDID типам данных].

    p.Article-Paragraph.
      Другими примерами часто используемых #[+Term--YDID ассоциативных массивов] являются многие поля
        #[+ImportantEntity--YDID package.json] — #[+SecondaryEntity__Code--YDID scripts],
        #[+SecondaryEntity__Code--YDID dependencies], #[+SecondaryEntity__Code--YDID devDependencies],
        #[+SecondaryEntity__Code--YDID peerDependencies] и так далее.

    p.Article-Paragraph.
      #[+ImportantEntity--YDID RawObjectDataProcessor], разумеется, работает с #[+Keyword--YDID обычными]
        #[+ImportantEntity--YDID ассоциативными массивами], которые представляют собой #[+Term--YDID объекты]
        со #[+Keyword--YDID строковыми] #[+Term--YDID ключами], однако #[+Keyword--YDID не]&nbsp;поддерживает
        входные даынне типа #[+ImportantEntity--YDID Map] ввиду их несовместимости с #[+ImportantEntity--YDID JSON].
      Тем #[+Keyword--YDID не]&nbsp;менее, с помощью функциональности #[+Term--YDID постобработки] можно преобразовать
        желаемые данные и к #[+ImportantEntity--YDID Map].


    //- ─── Индексные массивы ──────────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.objectLikeDataClassification.$children.indexedArrays.$heading,
      HTML_ID: localizedSectioning.objectLikeDataClassification.$children.indexedArrays.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      Набор данных, расположенных в памяти непосредственно друг за другом, доступ к которым осуществляется по
        #[+Term--YDID индексам] — #[+Term--YDID целым числам] #[+Keyphrase--YDID начиная с #[+ImportantEntity__Code--YDID 0]],
      Как в русском, так и в английском языках так сложилось, что просто #[+Term--YDID «массивами»]
        (#[+Term--YDID array(s)]) часто называют #[+Keyword--YDID именно] #[+Keyword__Contrast--YDID индексные],
        а #[+Keyword--YDID не]&nbsp;#[+Term--YDID ассоциативные массивы].

    p.Article-Paragraph.
      Во многих жёстко типизированных языках программирования (в частности, #[+SecondaryEntity--YDID C++],
        #[+SecondaryEntity--YDID C#] и #[+SecondaryEntity--YDID Java]) #[+Keyword--YDID обычные]
        #[+Keyword__Contrast--YDID индексные] #[+Term--YDID массивы] имеют #[+Keyword--YDID фиксированное] количество
         элементов и #[+Keyword--YDID часто] #[+Keyword__Contrast--YDID единый] #[+Keyword__Contrast--YDID тип]
         #[+Term--YDID элементов].
      Если требуется добавление и/или удаление #[+Term--YDID элементов], то используются специализированные
      #[+Term--YDID коллекции] — с #[+Keyphrase--YDID точки зрения концепции] те же самые
        #[+Term--YDID индексные массивы], но обеспечивающие возможность добавления и/или удаления
        #[+Term--YDID элементов] за счёт замены одного #[+Keyword--YDID стандартного] #[+Term--YDID массива] на другой
        внутри себя.

    p.Article-Paragraph.
      В же отношении #[+ImportantEntity--YDID ECMAScript], #[+Term--YDID индексный массив] —
      #[+Term__Contrast--YDID экземпляр] класснопободного #[+Term--YDID объекта] #[+ImportantEntity--YDID Array]
      (утверждение #[+ImportantEntity--YDID X instanceof Array] истинно).
      Поскольку такими #[+Term--YDID индексными массивами] можно гибко манипулировать (в частности, указывать
        #[+Term--YDID элементы] совершенно разных #[+Term--YDID типов], добавлять #[+Term--YDID элементы] и
        #[+Term--YDID удалять] их), то нужды в дополнительных #[+Term--YDID коллекциях] пока что #[+Keyword--YDID нет].

    p.Article-Paragraph.
      Аннотировать #[+Term--YDID индексный массив] в #[+ImportantEntity--YDID TypeScript] можно одним из следующих
        способов:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        const indexedArray: string[] = [ "Alpha", "Bravo" ];

        // Или

        const indexedArray: Array<string> = [ "Alpha", "Bravo" ];

    p.Article-Paragraph.
      Как и #[+Term--YDID объекты фиксированной структуры], #[+Term__Contrast--YDID индексные массивы] являются одним
        из самых популярных #[+Term--YDID типов данных], потому широко используется всюду.
      В отличие #[+Term--YDID объектов фиксированной структуры] и #[+Term--YDID ассоциативных массивов],
        #[+Keyword--YDID индексные] #[+Term--YDID массивы] #[+Keyword--YDID гарантируют] порядок #[+Term--YDID элементов],
        что и делает их очень ценными.


    //- ─── Кортежи ────────────────────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.objectLikeDataClassification.$children.tuple.$heading,
      HTML_ID: localizedSectioning.objectLikeDataClassification.$children.tuple.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      #[+Keyphrase--YDID С точки зрения концепции], #[+Term--YDID кортежи] — #[+Term__Contrast--YDID массивы]
        (вообще-то говоря, #[+Keyword--YDID не]&nbsp;только #[+Term--YDID индексные]) #[+Keyword--YDID фиксированного]
        количества #[+Term--YDID элементов].

    p.Article-Paragraph.
      До стандарта #[+ImportantEntity--YDID ECMAScript 2025] (не&nbsp;путать с упомянутым выше
        #[+ImportantEntity--YDID ECMAScript 2015]), в #[+ImportantEntity--YDID JavaScript]
        #[+Keyword--YDID не]&nbsp;было специализированного инструмента для создания #[+Term--YDID массивов] ограниченной
        длины.
      В #[+ImportantEntity--YDID TypeScript] термин #[+Term--YDID «кортеж»] (#[+Term--YDID «tuple»]) применялся
        #[+Keyword--YDID только] к #[+Keyword__Contrast--YDID индексным] #[+Term--YDID массивам], аннотируемым
        следующим образом:

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }): :code_listing--yda
        const tupleOfTwoElements: [ string, number ] = [ "ALPHA", 1 ];
        const tupleOfThreeElements: [ string, number, boolean ] = [ "BRAVO", 2, true ];

    p.Article-Paragraph.
      В стандарте #[+ImportantEntity--YDID ECMAScript 2025] появился новый тип данных #[+Term--YDID Tuple] который
        помимо того, что должен иметь фиксированное количество #[+Term--YDID элементов], #[+Keyword--YDID также]
        после инициализации является доступным #[+Keyword--YDID только]&nbsp;доступен для чтения, а потому для
        #[+Keyword--YDID гарантии] неизменяемости #[+Keyword--YDID не]&nbsp;может содержать в себе
        #[+Term--YDID объектов] #[+Keyword--YDID никаких] подтипов, будь то #[+ImportantEntity--YDID Array],
        #[+ImportantEntity--YDID Map], #[+ImportantEntity--YDID Set] или #[+Keyword--YDID любой]
        #[+Keyword--YDID другой] #[+Term--YDID объект].
      Этот тип данных слишком молодой, потому пройдёт некоторое время, прежде чем он станет широко поддерживаться
        в различных средах выполнения.
      Также можно предположить, что из-за своих ограничений он не&nbsp;получит широкого распространения, и естественно,
        #[+ImportantEntity--YDID RawObjectDataProcessor] такой тип данных #[+Keyword--YDID не]&nbsp;поддерживает.
      Ввиду этого, далее речь будет идти о #[+Keyword--YDID TypeScript-кортежах], которые уже #[+Keyword--YDID совместимы]
        с #[+ImportantEntity--YDID RawObjectDataProcessor].

    p.Article-Paragraph.
      #[+Term--YDID Кортежи] #[+Keyword--YDID не]&nbsp;очень популярны, однако примеры использования имеются.
      Так, #[+Term--YDID функция] #[+SecondaryEntity__Code--YDID useState] из #[+SecondaryEntity--YDID React] возвращает
        #[+Term--YDID кортеж] из двух элементов.
      #[+Keyphrase--YDID С натяжкой] можно назвать #[+Term--YDID «кортежами»] конфигурацию #[+Keyword--YDID многих]
        (#[+Keyphrase--YDID но #[+Keyword--YDID не]&nbsp;всех]) #[+Term--YDID ESLint-правил], в которых
        #[+Keyword--YDID второй] #[+Term--YDID элемент] #[+Keyword--YDID опциональный].
      Тем не&nbsp;менее, на каждой из двух позиций ожидается #[+Term--YDID элемент] #[+Keyword--YDID конкретного]
        #[+Term--YDID типа], что является основным признаком #[+Term--YDID кортежей].
