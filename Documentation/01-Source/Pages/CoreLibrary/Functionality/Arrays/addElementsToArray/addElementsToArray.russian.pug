extends ../../../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../../../SharedAssets/Markup/SharedAssets.russian.pug
  include ../../../../../SharedComponents/SharedComponents.russian.pug


block append Metadata

  -

    RegularWebPageTemplate__YDF.configure({
      metadata: {
        title: buildHTML_PageTitle("addElementsToArray"),
        description: MetaDescriptionTemplates.function({
          functionName: "addElementsToArray",
          whatFunctionDoes:
              "добавляет новые элементы в начало, конец или указанную позицию массива. " +
              "Возможно как изменение начального массива, так и создание нового на основе старого (но без глубокого " +
                "копирования)."
        })
      },
      stylesSheetsURIs: [
        "$CommonStyles",
        "$LayoutsStyles/TwoColumns/TwoColumnsLayout.css",
        "$PreMadesStyles",
        "@CustomizedExternalComponents"
      ]
    });

    RoutingEmulator.setCurrentRoute("coreLibrary.functionality.arrays.addingOfElements.addElementsToArray");

    LanguageDropDownList__YDF_DK.setLinks({
      english: routing.english.coreLibrary.$children.functionality.$children.arrays.$children.
          addingOfElements.$children.addElementsToArray.$URI,
      japanese: routing.japanese.coreLibrary.$children.functionality.$children.arrays.$children.
          addingOfElements.$children.addElementsToArray.$URI
    });

    const {
      $sectioning: localizedSectioning,
      $heading: topHeading
    } = localizedRouting.coreLibrary.$children.functionality.$children.arrays.$children.
        addingOfElements.$children.addElementsToArray;


block append HeadScripts

  if __IS_PRODUCTION_BUILDING_MODE__

    +GoogleAnalyticsScript


block append SpecificContent

  article

    +CallableExpressionScheme--YDF_DK({
      technicalName: "addElementsToArray",
      localizedDescriptiveHeading: "Добавить элементов в массив",
      genericParameters: [ "ArrayElement" ],
      parametersSpecification: [
        {
          genericTechnicalName: "sourceData",
          localizedName: "Входные данные",
          type: "SourceData",
          required: true
        }
      ],
      returnedValue: "Array<ArrayElement>",
      headingTag: "h1"
    })
      +ObjectTypeAbstract--YDF_DK({
        typeName: "SourceData",
        localizedDescriptiveHeading: "Входные данные",
        propertiesSpecification: {
          $intersection: [
            {
              newElements: {
                localizedInterpretation: "Новые элементы",
                type: "Array<ArrayElement>",
                required: true
              }
            },
            [
              {
                mutably: {
                  localizedInterpretation: "Мутабельно",
                  type: "boolean (только true)",
                  required: true
                },
                targetArray: {
                  localizedInterpretation: "Целевой массив",
                  type: "Array<ArrayElement>",
                  required: true
                }
              },
              {
                mutably: {
                  localizedInterpretation: "Мутабельно",
                  type: "boolean (только false)",
                  required: true
                },
                targetArray: {
                  localizedInterpretation: "Целевой массив",
                  type: "Array<ArrayElement>",
                  required: true
                }
              }
            ],
            [
              {
                toStart: {
                  localizedInterpretation: "В начало",
                  type: "boolean (только true)",
                  required: true
                }
              },
              {
                toEnd: {
                  localizedInterpretation: "В конец",
                  type: "boolean (только true)",
                  required: true
                }
              },
              {
                toPosition__numerationFrom0: {
                  localizedInterpretation: "На конкретную позицию (счёт с 0)",
                  type: "number (положительное целое число)",
                  required: true
                }
              },
              {
                toPosition__numerationFrom1: {
                  localizedInterpretation: "На конкретную позицию (счёт с 1)",
                  type: "number (натуральное число)",
                  required: true
                }
              }
            ]
          ]
        }
      })

    p.Article-Paragraph.
      Добавляет новые #[+Term--YDID элементы] в начало, конец или указанную позицию #[+Term--YDID индексного массива].
      Возможно как изменение исходного #[+Term--YDID массива] (#[+DefinableTerm--YDID мутирующее добавление]),
        #[+Keyword--YDID так и] создание нового на основе исходного #[+Keyword--YDID перед] добавлением
        #[+Term--YDID элементов] (#[+DefinableTerm--YDID немутирующее добавление]) — в зависимости от соответствующей
        #[+Term--YDID опции].
      При этом, в случае #[+Keyword--YDID немутирующего] добавления лишь заменяется прежний контейнер на новый,
        а #[+Term--YDID глубокое копирование] элементов #[+Keyword--YDID не]&nbsp;осуществляется
        (и #[+Keyword--YDID не]&nbsp;может быть осуществлено для #[+Keyword--YDID произвользованого] #[+Term--YDID объекта]).


    //- ━━━ Примеры ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.examples.$heading,
      HTML_ID: localizedSectioning.examples.$anchor
    }).Article-Heading2

    +AdmonitionBlock--YDF({　decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.guidance,　SVG_Icon: true　}).
      Поскольку многие читают эту страницу выборочно, то приведённые ниже объяснения содержат повторения
        важных моментов.


    //- ─── Добавление одного элемента в начало массива ────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheStartOfArray.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheStartOfArray.$anchor
    }).Article-Heading3

    //- ─── Мутирующее добавление ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheStartOfArray.$children.mutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheStartOfArray.$children.mutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          addElementsToArray({
            targetArray: sampleArray,
            newElements: [ "NEW_ELEMENT-1" ],
            toStart: true,
            mutably: true
          });

          console.log(sampleArray);


    mixin AddingOfOneElementToStartOrEndOfArrayMutably--TextFragment(properties)

      -

        const {
          newElementsCount,
          toEnd,
          similarNativeMethod
        } = properties;

        const similarNativeMethodName = toEnd ? "push" : "unshift";
        const similarNativeMethodReferenceURI = toEnd ? sharedExternalLinks.mdn.array.push : sharedExternalLinks.mdn.array.unshift;


      p.Article-Paragraph

        | Добавляем #[+Term--YDID элемент#{ newElementsCount === 1 ? "" : "ы" }]
        |   #[+SecondaryEntity__Code--YDID "NEW_ELEMENT-1"]
        if newElementsCount > 1
          | и #[+SecondaryEntity__Code--YDID "NEW_ELEMENT-2"]
        |   в #[+Keyword--YDID #{ toEnd ? "конец" : "начало" } ] #[+Term--YDID массива] #[+Term__Contrast--YDID строк].
        | #[+Term--YDID Опция] #[+ImportantEntity__Code--YDID mutably] сделана #[+Keyword--YDID обязательной]
        |   #[+Keyword__Contrast--YDID не]&nbsp;случайно: программист #[+Keyword--YDID обязан] чётко понимать, что он делает.
        | Поскольку в данном примере установлено значение #[+SecondaryEntity__Code--YDID true], то #[+Keyword--YDID исходный]
        |   #[+Term--YDID массив] #[+Keyword__Contrast--YDID изменится] и в результате будет:
        |
        if newElementsCount === 1
          if toEnd
            +SecondaryEntity__Code--YDID [ "INITIALLY_EXISTED_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2", "NEW_ELEMENT-1" ]
          else
            +SecondaryEntity__Code--YDID [ "NEW_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2" ]
        else
          if toEnd
            +SecondaryEntity__Code--YDID
              | [ "INITIALLY_EXISTED_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2", "NEW_ELEMENT-1", "NEW_ELEMENT-2" ]
          else
            +SecondaryEntity__Code--YDID
              | [ "NEW_ELEMENT-1", "NEW_ELEMENT-2", "INITIALLY_EXISTED_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2" ]
        | .

      +AdmonitionBlock--YDF({ decorativeVariation: AdmonitionBlock__YDF.DecorativeVariations.warning, SVG_Icon: true }).
        При таком варианте использования целевой #[+Term--YDID массив] (#[+ImportantEntity__Code--YDID targetArray])
          #[+Keyword--YDID не]&nbsp;может иметь #[+Term--YDID тип] #[+ImportantEntity__Code--YDID ReadonlyArray],
          поскольку #[+Term--YDID функция] будет вносить изменения в этот #[+Term--YDID массив].

      p.Article-Paragraph
        | Такое использование #[+Term--YDID функции] близко к #[+Term__Contrast--YDID нативному методу]
        |
        +Link--YDF({ unendorsedExternalURI: similarNativeMethodReferenceURI }).Article-Link= similarNativeMethodName
        | .
        | Разница в том, что #[+ImportantEntity__Code--YDID addElementsToArray] #[+Keyword--YDID всегда]&nbsp;возвращает
        |   #[+Keyword__Contrast--YDID обновлённый] #[+Term--YDID массив], а #[+Keyword--YDID не]&nbsp;его количество
        |   #[+Term--YDID элементов], как #[+ImportantEntity__Code--YDID #{ similarNativeMethodName }].
        | Впрочем, если нужно количество #[+Term--YDID элементов] #[+Keyword--YDID нового] #[+Term--YDID массива], то
        |   можно обратиться к #[+Term--YDID свойству] #[+ImportantEntity__Code--YDID length] у
        |   #[+Term--YDID возвращаемого значения] без определения новой #[+Term--YDID переменной].

      p.Article-Paragraph.
        К тому же в отличие от #[+ImportantEntity__Code--YDID #{ similarNativeMethodName }] при знании базового английского
          полностью очевидно, что делает #[+ImportantEntity__Code--YDID addElementsToArray], куда добавляет
          #[+Term--YDID элементы] и произойдёт ли что-то с #[+Keyword--YDID исходным] #[+Term--YDID массивом].
        Да, вызов #[+ImportantEntity__Code--YDID addElementsToArray] набирать на клавиатуре дольше, чем
          #[+ImportantEntity__Code--YDID #{ similarNativeMethodName }], но кристально прозрачная понятность кода а значит его
          #[+Keyphrase--YDID поддерживаемость гораздо важнее, чем скорость ввода #[+Keyword--YDID начального] кода].
        К сожалению, многих программистов (особенно начинающих) это не&nbsp;убеждает, потому что человеческая психология
          предпочитает сиюминутную выгоду большей выгоде будущем.
        В разработке сайтов и программного обеспечения эта склонность во многом ответственна за код, который быстро
          становится крайне трудно поддерживать, что делает разрабатываемые сайты и приложения убыточными.

      p.Article-Paragraph
        | Что касается скорости ввода, то современные #[+Term--YDID интегрированные среды разработки] позволяют эту
        |   проблему решить.
        | В частности, для
        |
        +Link--YDF({
          unendorsedExternalURI: sharedExternalLinks.jetBrains.intelliJ_IDEA_FamilyIDEs
        }).Article-Link интегрированных сред разработки семейства IntelliJ IDEA
        |
        |   поддерживается
        +Link--YDF({
          unendorsedExternalURI: sharedExternalLinks.jetBrains.YDEE_Plugin
        }).Article-Link официальный плагин YDEE
        |   , включающий в себя
        |
        +Link--YDF({
          unendorsedExternalURI: sharedExternalLinks.jetBrains.liveTemplates
        }).Article-Link шаблоны быстрого ввода
        |   (в том числе и для #[+ImportantEntity__Code--YDID addElementsToArray]).

    +AddingOfOneElementToStartOrEndOfArrayMutably--TextFragment({ newElementsCount: 1, toEnd: false })


    //- ─── Немутирующее добавление ────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheStartOfArray.$children.immutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheStartOfArray.$children.immutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          const updatedSampleArray: Array<string> = addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1" ],
            toStart: true,
            mutably: false
          });

          console.log(sampleArray);
          console.log(updatedSampleArray);


    mixin NoticeAboutOneLevelCopying

      p.Article-Paragraph.
        Однако, #[+Keyword--YDID полную] («глубокую») #[+Term--YDID копию] #[+Term--YDID массива] эта #[+Term--YDID функция]
          #[+Keyword--YDID не]&nbsp;делает.
        Начнём с того, что #[+Keyphrase--YDID в общем случае] #[+Keyword--YDID полную] #[+Term--YDID копию]
          #[+Keyword--YDID произвольного] #[+Term__Contrast--YDID объекта] (кстати, #[+ImportantEntity--YDID Array]
          — это #[+Keyphrase--YDID частный случай] #[+Term--YDID объекта] #[+Keyphrase--YDID в ECMAScript-языках]) сделать
          #[+Keyword--YDID невозможно].
        Например, #[+Term--YDID замыкания] и добавленные в #[+ImportantEntity--YDID ES2022]
          #[+Term--YDID закрытые поля] #[+Keyword--YDID не]&nbsp;могут быть скопированы, а значит #[+Term--YDID функция]
          для глубокого копирования #[+Keyword--YDID произвольного] #[+Term--YDID объекта]
          #[+Keyword__Contrast--YDID не]&nbsp;может быть разработана.
        #[+Keyphrase--YDID В случае с добавлением новых #[+Term--YDID элементов] в #[+Term--YDID массив]] это
          #[+Keyword--YDID не]&nbsp;критично даже в #[+SecondaryEntity--YDID React], чего нельзя сказать про изменение
          #[+Term--YDID свойств] #[+Term__Contrast--YDID элемента] типа #[+Term--YDID «объект»] в
          #[+Term__Contrast--YDID массиве] — придётся создавать как новый #[+Term--YDID массив], так и новый
          #[+Term--YDID элемент] на основе старого.


    mixin AddingOfOneElementToStartOrEndOfArrayImmutably--TextFragment(properties)

      -

        const { newElementsCount, toEnd } = properties;

      p.Article-Paragraph
        | В случае #[+Keyword--YDID немутирующего] добавления #[+Term--YDID элементов] будет создан #[+Keyword--YDID новый]
        |   #[+Term--YDID массив] на основе старого, и только затем в #[+Keyword--YDID новый]
        |
        if newElementsCount === 1
          | будет добавлен указанный #[+Term--YDID элемент]
        else
          | будут добавлены указанные #[+Term--YDID элементы]
        | .
        | Таким образом, #[+Keyword--YDID исходный] #[+Term--YDID массив] #[+SecondaryEntity__Code--YDID sampleArray] останется
        |   #[+Keyword--YDID неизменным], а #[+Keyword__Contrast--YDID новый]
        |   (#[+SecondaryEntity__Code--YDID updatedSampleArray]) будет иметь значение
        |
        if newElementsCount === 1
          if toEnd
            +SecondaryEntity__Code--YDID [ "INITIALLY_EXISTED_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2", "NEW_ELEMENT-1" ]
          else
            +SecondaryEntity__Code--YDID [ "NEW_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2" ]
        else
          if toEnd
            +SecondaryEntity__Code--YDID
              | [ "INITIALLY_EXISTED_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2", "NEW_ELEMENT-1", "NEW_ELEMENT-2" ]
          else
            +SecondaryEntity__Code--YDID
              | [ "NEW_ELEMENT-1", "NEW_ELEMENT-2", "INITIALLY_EXISTED_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2" ]
        | .

      p.Article-Paragraph.
        Подобные антиинтуитивные манипуляции затребованы в основном во #[+Term--YDID фронтенд-фрейворках], где разработчики
          некоторых из них (в том числе #[+SecondaryEntity--YDID React]) возлагают на пользователей рутину по созданию нового
          #[+Term--YDID объекта состояния] на основе старого.
        #[+ImportantEntity__Code--YDID addElementsToArray] позволяет написать более понятный код, а если требуется добавить
          один или больше элементов на #[+Keyword--YDID промежуточные] позиции #[+Term--YDID массива], то код будет
          ещё и значительно проще.

      +NoticeAboutOneLevelCopying


    +AddingOfOneElementToStartOrEndOfArrayImmutably--TextFragment({ newElementsCount: 1, toEnd: false })


    //- ─── Добавление одного элемента в конец массива ─────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheEndOfArray.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheEndOfArray.$anchor
    }).Article-Heading3

    //- ─── Мутирующее добавление ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheEndOfArray.$children.mutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheEndOfArray.$children.mutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          addElementsToArray({
            targetArray: sampleArray,
            newElements: [ "NEW_ELEMENT-1" ],
            toEnd: true,
            mutably: true
          });

          console.log(sampleArray);

    +AddingOfOneElementToStartOrEndOfArrayMutably--TextFragment({ newElementsCount: 1, toEnd: true })


    //- ─── Немутирующее добавление ────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheEndOfArray.$children.immutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheEndOfArray.$children.immutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          const updatedSampleArray: Array<string> = addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1" ],
            toEnd: true,
            mutably: false
          });

          console.log(sampleArray);
          console.log(updatedSampleArray);

    +AddingOfOneElementToStartOrEndOfArrayImmutably--TextFragment({ newElementsCount: 1, toEnd: true })


    //- ─── Добавление одного элемента на конкретную позицию (нумерация с 0) ───────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom0.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom0.$anchor
    }).Article-Heading3

    //- ─── Мутирующее добавление ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom0.
          $children.mutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom0.
          $children.mutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1" ],
            toPosition__numerationFrom0: 1,
            mutably: true
          });

          console.log(sampleArray);


    mixin AddingOfOneElementToSpecificPositionOfArrayMutably--TextFragment(properties)

      - const { numerationFrom, newElementsCount } = properties

      p.Article-Paragraph
        | Добавляем
        |
        if newElementsCount === 1
          | новый #[+Term--YDID элемент] #[+SecondaryEntity__Code--YDID "NEW_ELEMENT-1"]
        else
          | новые #[+Term--YDID элементы] #[+SecondaryEntity__Code--YDID "NEW_ELEMENT-1"] и
          |   #[+SecondaryEntity__Code--YDID "NEW_ELEMENT-2"]
        |
        |   на #[+SecondaryEntity--YDID #{ numerationFrom === 0 ? "1-ую" : "2-ую" }] позицию
        |   #[+Keyphrase--YDID при счёте с #[+SecondaryEntity--YDID #{ numerationFrom }]].
        | Так как #[+Keyword--YDID изначально] в #[+Term--YDID массиве] #[+SecondaryEntity--YDID 2] #[+Term--YDID элемента],
        |   то #[+Keyword--YDID новы#{ newElementsCount === 1 ? "й" : "е" }]
        |   #[+Term--YDID элемент#{ newElementsCount === 1 ? "" : "ы" }]
        |   #{ newElementsCount === 1 ? "окажется" : "окажутся" } ровно между ними и #[+Keyword--YDID обновлённый]
        |   #[+Term--YDID массив] будет:
        |
        if newElementsCount === 1
          +SecondaryEntity__Code--YDID [ "INITIALLY_EXISTED_ELEMENT-1", "NEW_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2" ]
        else
          +SecondaryEntity__Code--YDID
            | [ "INITIALLY_EXISTED_ELEMENT-1", "NEW_ELEMENT-1", "NEW_ELEMENT-2", "INITIALLY_EXISTED_ELEMENT-2" ]
        | .

      p.Article-Paragraph.
        Сделать то же самое без использования библиотек можно с помощью #[+Term--YDID нативного метода]
          #[+Link--YDF({ unendorsedExternalURI: sharedExternalLinks.mdn.array.splice }).Article-Link splice], но:

      ul.Article-UnorderedList

        li.
          Этот #[+Term--YDID метод] рассчитан в первую очередь на #[+Keyword--YDID удаление] #[+Term--YDID элементов] из
            #[+Term__Contrast--YDID массива].
          Если нам нужно #[+Keyword--YDID только] #[+Keyword__Contrast--YDID добавить] новые элементы
            #[+Keyphrase--YDID ничего не&nbsp;удаляя], то нам будут мешаться #[+ImportantEntity--YDID 2-ой]
            #[+Term--YDID параметр] (при таком варианте использования этого #[+Term--YDID метода] он
            #[+Keyword--YDID должен] иметь значение #[+SecondaryEntity--YDID 0]).

        li.
          Он сложноват для чтения и запоминания: неочевидно, какие #[+Term--YDID параметры] за что отвечают.
          Один #[+Term--YDID параметр] обозначают #[+Term--YDID индекс] #[+Term__Contrast--YDID элемента], другой —
            #[+Keyword--YDID количество] #[+Term--YDID элементов], а далее и вовсе идут новые #[+Term--YDID элементы].

    +AddingOfOneElementToSpecificPositionOfArrayMutably--TextFragment({ numerationFrom: 0, newElementsCount: 1 })


    //- ─── Немутирующее добавление ────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom0.
          $children.immutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom0.
          $children.immutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          const updatedSampleArray: Array<string> = addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1" ],
            toPosition__numerationFrom0: 1,
            mutably: false
          });

          console.log(sampleArray);
          console.log(updatedSampleArray);

    mixin AddingOfOneElementToSpecificPositionOfArrayImmutably--TextFragment(properties)

      - const { numerationFrom, newElementsCount } = properties

      p.Article-Paragraph
        | При #[+ImportantEntity__Code--YDID mutably: false] будет создан #[+Keyword--YDID новый]
        |   #[+Term--YDID массив] на основе исходого, а дальнейшие манипуляции будут проводиться с #[+Keyword--YDID новым].
        | В данном примере, после создания #[+Keyword--YDID нового] #[+Term--YDID массива] на позицию
        |   #[+SecondaryEntity--YDID #{ numerationFrom + 1 }]
        |   #[+Keyphrase--YDID при счёте с #[+SecondaryEntity--YDID #{ numerationFrom }]]
        |
        if newElementsCount === 1
          | будет добавлен #[+Term--YDID элемент] #[+SecondaryEntity__Code--YDID "NEW_ELEMENT-1"]
        else
          | будут добавлены #[+Term--YDID элементы] #[+SecondaryEntity__Code--YDID "NEW_ELEMENT-1"] и
          |   #[+SecondaryEntity__Code--YDID "NEW_ELEMENT-2"]
        |   , в результате чего #[+Keyword--YDID новый] #[+Term--YDID массив] будет:
        |
        if newElementsCount === 1
          +SecondaryEntity__Code--YDID.
            [ "INITIALLY_EXISTED_ELEMENT-1", "NEW_ELEMENT-1", "INITIALLY_EXISTED_ELEMENT-2" ]
        else
          +SecondaryEntity__Code--YDID.
            "INITIALLY_EXISTED_ELEMENT-1", "NEW_ELEMENT-1", "NEW_ELEMENT-2", "INITIALLY_EXISTED_ELEMENT-2" ]
        |   .

      +NoticeAboutOneLevelCopying

      p.Article-Paragraph.
        До недавнего времени без использования библиотек проделать все эти манипуляции в одного выражения было
          невозможно, потому для достижения такого же эффекта приходилось:

      ol.Article-OrderedList
        li Создавать новый #[+Term--YDID массив]
        li Копировать в него #[+Term--YDID элементы] старого
        li.
          Вызывать #[+Term--YDID метод] #[+ImportantEntity__Code--YDID splice] у #[+Keyword--YDID нового]
            #[+Term--YDID массива]

      p.Article-Paragraph.
        Собственно, именно эти рутины #[+ImportantEntity__Code--YDID addElementsToArray] и делает за Вас при
          #[+ImportantEntity__Code--YDID mutable: false].

      p.Article-Paragraph.
        В #[+ImportantEntity--YDID 2023] году введён #[+Term--YDID метод] #[+ImportantEntity__Code--YDID toSpliced], который
          делает всё то же, что и #[+ImportantEntity__Code--YDID splice], но при этом #[+Keyword--YDID предварительно]
          создаёт #[+Keyword__Contrast--YDID новый] #[+Term--YDID массив] на основе исходного.
        На момент #[+ImportantEntity--YDID весны 2023], он поддерживался #[+Keyword--YDID не] всеми популярными браузерами,
          а в #[+ImportantEntity--YDID Node.js] #[+Term--YDID данный] метод появился в версии #[+ImportantEntity--YDID 20].
        Так или иначе, необходимость запоминать, что означают #[+Term--YDID параметры] #[+ImportantEntity__Code--YDID splice] и
          #[+ImportantEntity__Code--YDID toSpliced] оставляют актуальным #[+ImportantEntity__Code--YDID addElementsToArray],
          а потому удаление этой #[+Term--YDID функции] из библиотеки в связи с появлением
          #[+ImportantEntity__Code--YDID toSpliced] #[+Keyword--YDID не] планируется.

    +AddingOfOneElementToSpecificPositionOfArrayImmutably--TextFragment({ numerationFrom: 0, newElementsCount: 1 })


    //- ─── Добавление одного элемента на конкретную позицию (нумерация с 1) ───────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom1.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom1.$anchor
    }).Article-Heading3

    p.Article-Paragraph.
      Хотя в программировании и стандартизирован счёт с #[+ImportantEntity--YDID 0], зачастую он запутывает,
        а потому является источником ошибок.
      Этой проблеме и обязано наличие опции #[+ImportantEntity__Code--YDID toPosition__numerationFrom1], которая, как
        следует из перевода, позволяет указать позицию при счёте с #[+ImportantEntity--YDID 1] и должна быть указана
        #[+Keyword--YDID вместо] #[+ImportantEntity__Code--YDID toPosition__numerationFrom0].


    //- ─── Мутирующее добавление ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom1.
          $children.mutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom1.
          $children.mutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1" ],
            toPosition__numerationFrom0: 2,
            mutably: true
          });

          console.log(sampleArray);

    +AddingOfOneElementToSpecificPositionOfArrayMutably--TextFragment({ numerationFrom: 1, newElementsCount: 2 })


    //- ─── Немутирующее добавление ────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom1.
          $children.immutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfOneElementToTheSpecificPositionOfArrayNumerationFrom1.
          $children.immutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          const updatedSampleArray: Array<string> = addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1" ],
            toPosition__numerationFrom0: 2,
            mutably: false
          });

          console.log(sampleArray);
          console.log(updatedSampleArray);

    +AddingOfOneElementToSpecificPositionOfArrayImmutably--TextFragment({ numerationFrom: 1, newElementsCount: 1 })


    //- ─── Добавление нескольких элементов в начало массива ───────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheStartOfArray.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheStartOfArray.$anchor
    }).Article-Heading3

    //- ─── Мутирующее добавление ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheStartOfArray.
          $children.mutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheStartOfArray.
          $children.mutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          addElementsToArray({
            targetArray: sampleArray,
            newElements: [ "NEW_ELEMENT-1", "NEW_ELEMENT-2" ],
            toStart: true,
            mutably: true
          });

          console.log(sampleArray);

    +AddingOfOneElementToStartOrEndOfArrayMutably--TextFragment({ newElementsCount: 2, toEnd: false })


    //- ─── Немутирующее добавление ────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheStartOfArray.
          $children.immutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheStartOfArray.
          $children.immutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          const updatedSampleArray: Array<string> = addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1", "NEW_ELEMENT-2" ],
            toStart: true,
            mutably: false
          });

          console.log(sampleArray);
          console.log(updatedSampleArray);

    +AddingOfOneElementToStartOrEndOfArrayImmutably--TextFragment({ newElementsCount: 2, toEnd: false })


    //- ─── Добавление нескольких элементов в конец массива ────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheEndOfArray.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheEndOfArray.$anchor
    }).Article-Heading3

    //- ─── Мутирующее добавление ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheEndOfArray.
          $children.mutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheEndOfArray.
          $children.mutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          addElementsToArray({
            targetArray: sampleArray,
            newElements: [ "NEW_ELEMENT-1", "NEW_ELEMENT-2" ],
            toEnd: true,
            mutably: true
          });

          console.log(sampleArray);

    +AddingOfOneElementToStartOrEndOfArrayMutably--TextFragment({ newElementsCount: 2, toEnd: true })


    //- ─── Немутирующее добавление ────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheEndOfArray.
          $children.immutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheEndOfArray.
          $children.immutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          const updatedSampleArray: Array<string> = addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1", "NEW_ELEMENT-2" ],
            toEnd: true,
            mutably: false
          });

          console.log(sampleArray);
          console.log(updatedSampleArray);

    +AddingOfOneElementToStartOrEndOfArrayImmutably--TextFragment({ newElementsCount: 2, toEnd: true })


    //- ─── Добавление нескольких элементов на конкретную позицию (нумерация с 0) ──────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom0.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom0.$anchor
    }).Article-Heading3

    //- ─── Мутирующее добавление ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom0.
          $children.mutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom0.
          $children.mutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1", "NEW_ELEMENT-2" ],
            toPosition__numerationFrom0: 1,
            mutably: true
          });

          console.log(sampleArray);

    +AddingOfOneElementToSpecificPositionOfArrayMutably--TextFragment({ numerationFrom: 0, newElementsCount: 2 })


    //- ─── Немутирующее добавление ────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom0.
          $children.immutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom0.
          $children.immutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          const updatedSampleArray: Array<string> = addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1", "NEW_ELEMENT-2" ],
            toPosition__numerationFrom0: 1,
            mutably: false
          });

          console.log(sampleArray);

    +AddingOfOneElementToSpecificPositionOfArrayImmutably--TextFragment({ numerationFrom: 0, newElementsCount: 2 })


    //- ─── Добавление нескольких элементов на конкретную позицию (нумерация с 1) ──────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom1.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom1.$anchor
    }).Article-Heading3

    //- ─── Мутирующее добавление ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom1.
          $children.mutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom1.
          $children.mutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1", "NEW_ELEMENT-2" ],
            toPosition__numerationFrom0: 2,
            mutably: true
          });

          console.log(sampleArray);

    +AddingOfOneElementToSpecificPositionOfArrayMutably--TextFragment({ numerationFrom: 1, newElementsCount: 2 })


    //- ─── Немутирующее добавление ────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 4,
      text: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom1.
          $children.immutableAdding.$heading,
      HTML_ID: localizedSectioning.examples.$children.addingOfMultipleElementsToTheSpecificPositionNumerationFrom1.
          $children.immutableAdding.$anchor
    }).Article-Heading4

    +CodeViewer--YDF
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })
        :code_listing--yda
          const sampleArray: Array<string> = [
            "INITIALLY_EXISTED_ELEMENT-1",
            "INITIALLY_EXISTED_ELEMENT-2"
          ];

          const updatedSampleArray: Array<string> = addElementsToArray({
            targetArray: experimentalSample,
            newElements: [ "NEW_ELEMENT-1", "NEW_ELEMENT-2" ],
            toPosition__numerationFrom0: 1,
            mutably: false
          });

          console.log(sampleArray);

    +AddingOfOneElementToSpecificPositionOfArrayImmutably--TextFragment({ numerationFrom: 1, newElementsCount: 2 })


    +IntelliJ_IDEA_IDEs_LiveTemplateUsageGuidance({
      imageURI: "@AssociatedWithPages/CoreLibrary/Functionality/Arrays/" +
          "addElementsToArray/Images/addElementsToArray-LiveTemplate",
      relatedTableOfContentsMetadata: localizedSectioning.IntelliJ_IDEA_IDEs_LiveTemplateUsageGuidance
    })

      ol.Article-OrderedList

        li.
          Скопируйте в буфер обмен имя #[+Term--YDID переменной], содержащей #[+Term--YDID массив], либо само
            #[+Term--YDID выражение массива].
          Чтобы #[+Term--YDID среда разработки] смогла автоматически заполнить позицию единственного #[+Term--YDID параметра]
            нужным значением, сформируйте привычку делать это копирование перед тем, как начинать вводить
            #[+Term--YDID Live template] #[+Term__Contrast--YDID функции] #[+ImportantEntity--YDID addElementsToArray].

        li

          | Начните набирать имя #[+Term--YDID функции] — #[+ImportantEntity--YDID addElementsToArray].
          | Подсветится #[+ImportantEntity--YDID 2] варианта автодополнения:

          ol.Article-OrderedList

            li.
              Круглая иконка с буквой — это просто автодополнение имени #[+Term--YDID функции]; #[+Keyword--YDID стандартная]
                функциональность #[+Term--YDID среды разработки].
              Нажатие на #[+ImportantEntity--YDID Enter] введёт полное имя #[+Term--YDID функции], а также при необходимости
                объявления #[+Term--YDID импорта] этой #[+Term__Contrast--YDID функции].
              Неплохо, однако это не&nbsp;предел, до которого можно частично автоматизировать процесс.

            li.
              Иконка с клише — это как раз нужный шаблон.
              Нажмите #[+ImportantEntity--YDID Enter].
              Произойдёт вставка шаблона кода, при этом значение свойства #[+ImportantEntity__Code--YDID targetArray]
                будет автоматически выделено и заполнено содержимым буфера обмена.
              Поскольку при следовании данному руководству менять подставленное значение
                #[+ImportantEntity__Code--YDID targetArray] на другое не&nbsp;требуется, выйдете из режима редактирования
                свойства #[+ImportantEntity__Code--YDID targetArray], нажав #[+ImportantEntity--YDID Enter] ещё раз.

        li.
          Заполните значение #[+ImportantEntity__Code--YDID newElements] простым вводом символов.
          Когда закончите, нажмите #[+ImportantEntity--YDID Enter].
          Если этому будет препятствовать на этот раз ненужное Вам автодополнение, то сначала нажмите
            #[+ImportantEntity--YDID Esc].

        li.
          Будет предложено выбрать значение #[+Term--YDID свойства] #[+ImportantEntity--YDID mutably] из выпадающего списка.
          По умолчанию выбрано значение #[+ImportantEntity__Code--YDID true] — если Вам оно и нужно, то сразу нажимайте
            #[+ImportantEntity--YDID Enter], в противном случае предварительно клавишей со стрелкой вниз выберете
            опцию #[+ImportantEntity__Code--YDID false].

        li.
          Будет преложено введи значение #[+Term--YDID свойства] #[+ImportantEntity__Code--YDID toPosition__numerationFrom0].
          Одновременно с ним, будет введено и значение #[+ImportantEntity__Code--YDID toPosition__numerationFrom1],
            однако #[+Keyphrase--YDID как минимум одно из]&nbsp;этих #[+Term--YDID свойств] всё равно
            #[+Keyword--YDID потребуется] удалить.
          Если Вам нужна одна из этих опций, то введите нужное числовое значение или имя нужной переменной.
          В любом случае, когда закончите этот шаг, нажмите #[+ImportantEntity__Code--YDID Enter].

        li.
          Удалите лишний код.
          Из свойств #[+ImportantEntity__Code--YDID toStart], #[+ImportantEntity__Code--YDID toEnd],
            #[+ImportantEntity__Code--YDID toPosition__numerationFrom0] и
            #[+ImportantEntity__Code--YDID toPosition__numerationFrom1] должно остаться #[+Keyword--YDID только]
            #[+Keyword__Contrast--YDID одно].

      p.Article-Paragraph.
        Вы можете использовать #[+Keyword--YDID алиас] этого #[+Term--YDID LiveTemplate-а] —
          #[+ImportantEntity__Code--YDID aeta], состоящий из первых букв всех слов, которые включает в себя имя
          #[+Term--YDID функции].
        Однако недостаток таких алиасов в том, что их приходится запоминать, а для того, чтобы получить подсказку
          #[+ImportantEntity--YDID addElementsToArray], достаточно лишь помнить, с чего начинается это имя
          #[+Term--YDID функции].


    //- ━━━ Внешние ссылки ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.externalLinks.$heading,
      HTML_ID: localizedSectioning.externalLinks.$anchor
    }).Article-Heading2

    +LinksCardsFlow--YDF

      +LinksCardsFlow-ItemWithSVG_Icon--YDF({
        unendorsedExternalURI: "https://github.com/TokugawaTakeshi/Yamato-Daiwa-ES-Extensions/blob/master/" +
            "CoreLibrary/Package/Source/Arrays/addElementsToArray.ts",
        title: "Исходный код"
      }): +File__SourceCode--YDF_Icon.LinksCardsFlow--YDF-SVG_Icon

      +LinksCardsFlow-ItemWithSVG_Icon--YDF({
        unendorsedExternalURI: "https://github.com/TokugawaTakeshi/Yamato-Daiwa-ES-Extensions/blob/master/" +
            "CoreLibrary/Package/Tests/Automated/Arrays/addElementsToArray.test.ts",
        title: "Код тестов"
      }): +File__TestCode--YDF_Icon.LinksCardsFlow--YDF-SVG_Icon
